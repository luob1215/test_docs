"use strict";(self.webpackChunkdeno_docs=self.webpackChunkdeno_docs||[]).push([[2156],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>m});var o=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=o.createContext({}),p=function(e){var n=o.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},c=function(e){var n=p(e.components);return o.createElement(l.Provider,{value:n},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},u=o.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),d=p(t),u=a,m=d["".concat(l,".").concat(u)]||d[u]||h[u]||r;return t?o.createElement(m,s(s({ref:n},c),{},{components:t})):o.createElement(m,s({ref:n},c))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,s=new Array(r);s[0]=u;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i[d]="string"==typeof e?e:a,s[1]=i;for(var p=2;p<r;p++)s[p]=t[p];return o.createElement.apply(null,s)}return o.createElement.apply(null,t)}u.displayName="MDXCreateElement"},36401:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>p});var o=t(87462),a=(t(67294),t(3905));const r={},s="HTTP Server APIs",i={unversionedId:"manual/runtime/http_server_apis",id:"manual/runtime/http_server_apis",title:"HTTP Server APIs",description:"Deno currently has two HTTP Server APIs:",source:"@site/runtime/manual/runtime/http_server_apis.md",sourceDirName:"manual/runtime",slug:"/manual/runtime/http_server_apis",permalink:"/runtime/manual/runtime/http_server_apis",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"runtimeGuideHome",previous:{title:"Deno namespace APIs",permalink:"/runtime/manual/runtime/builtin_apis"},next:{title:"Permission APIs",permalink:"/runtime/manual/runtime/permission_apis"}},l={},p=[{value:"A &quot;Hello World&quot; server",id:"a-hello-world-server",level:3},{value:"Inspecting the incoming request",id:"inspecting-the-incoming-request",level:3},{value:"Responding with a response",id:"responding-with-a-response",level:3},{value:"HTTPS support",id:"https-support",level:3},{value:"HTTP/2 support",id:"http2-support",level:3},{value:"Automatic body compression",id:"automatic-body-compression",level:3},{value:"<code>Deno.serveHttp</code>",id:"denoservehttp",level:2},{value:"Listening for a connection",id:"listening-for-a-connection",level:3},{value:"Handling connections",id:"handling-connections",level:3},{value:"Serving HTTP",id:"serving-http",level:3},{value:"HTTP Requests and Responses",id:"http-requests-and-responses",level:4},{value:"HTTP/2 Support",id:"http2-support-1",level:3},{value:"Serving WebSockets",id:"serving-websockets",level:3}],c={toc:p},d="wrapper";function h(e){let{components:n,...t}=e;return(0,a.kt)(d,(0,o.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"http-server-apis"},"HTTP Server APIs"),(0,a.kt)("p",null,"Deno currently has two HTTP Server APIs:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://deno.land/api?s=Deno.serve"},(0,a.kt)("inlineCode",{parentName:"a"},"Deno.serve")),": native, ",(0,a.kt)("em",{parentName:"li"},"higher-level"),",\nsupports HTTP/1.1 and HTTP2, this is the preferred API to write HTTP servers\nin Deno."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://deno.land/api?s=Deno.serveHttp"},(0,a.kt)("inlineCode",{parentName:"a"},"Deno.serveHttp")),": native,\n",(0,a.kt)("em",{parentName:"li"},"low-level"),", supports HTTP/1.1 and HTTP2."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#a-hello-world-server"},'A "Hello World" server')),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#inspecting-the-incoming-request"},"Inspecting the incoming request")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#responding-with-a-response"},"Responding with a response")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#https-support"},"HTTPS support")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#http2-support"},"HTTP/2 support")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#serving-websockets"},"Serving WebSockets"))),(0,a.kt)("h3",{id:"a-hello-world-server"},'A "Hello World" server'),(0,a.kt)("p",null,"To start a HTTP server on a given port, you can use the ",(0,a.kt)("inlineCode",{parentName:"p"},"Deno.serve")," function.\nThis function takes a handler function that will be called for each incoming\nrequest, and is expected to return a response (or a promise resolving to a\nresponse)."),(0,a.kt)("p",null,'Here is an example of a server that returns a "Hello, World!" response for each\nrequest:'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'Deno.serve((_req) => {\n  return new Response("Hello, World!");\n});\n')),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"\u2139\ufe0f The handler can also return a ",(0,a.kt)("inlineCode",{parentName:"p"},"Promise<Response>"),", which means it can be an\n",(0,a.kt)("inlineCode",{parentName:"p"},"async")," function.")),(0,a.kt)("p",null,"By default ",(0,a.kt)("inlineCode",{parentName:"p"},"Deno.serve")," will listen on port ",(0,a.kt)("inlineCode",{parentName:"p"},"8000"),", but this can be changed by\npassing in a port number in options bag as the first or second argument:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'// To listen on port 4242.\nDeno.serve({ port: 4242 }, handler);\n\n// To listen on port 4242 and bind to 0.0.0.0.\nDeno.serve({ port: 4242, hostname: "0.0.0.0", handler });\n')),(0,a.kt)("h3",{id:"inspecting-the-incoming-request"},"Inspecting the incoming request"),(0,a.kt)("p",null,"Most servers will not answer with the same response for every request. Instead\nthey will change their answer depending on various aspects of the request: the\nHTTP method, the headers, the path, or the body contents."),(0,a.kt)("p",null,"The request is passed in as the first argument to the handler function. Here is\nan example showing how to extract various parts of the request:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'Deno.serve(async (req) => {\n  console.log("Method:", req.method);\n\n  const url = new URL(req.url);\n  console.log("Path:", url.pathname);\n  console.log("Query parameters:", url.searchParams);\n\n  console.log("Headers:", req.headers);\n\n  if (req.body) {\n    const body = await req.text();\n    console.log("Body:", body);\n  }\n\n  return new Response("Hello, World!");\n});\n')),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"\u26a0\ufe0f Be aware that the ",(0,a.kt)("inlineCode",{parentName:"p"},"req.text()")," call can fail if the user hangs up the\nconnection before the body is fully received. Make sure to handle this case.\nDo note this can happen in all methods that read from the request body, such\nas ",(0,a.kt)("inlineCode",{parentName:"p"},"req.json()"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"req.formData()"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"req.arrayBuffer()"),",\n",(0,a.kt)("inlineCode",{parentName:"p"},"req.body.getReader().read()"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"req.body.pipeTo()"),", etc.")),(0,a.kt)("h3",{id:"responding-with-a-response"},"Responding with a response"),(0,a.kt)("p",null,'Most servers also do not respond with "Hello, World!" to every request. Instead\nthey might respond with different headers, status codes, and body contents (even\nbody streams).'),(0,a.kt)("p",null,"Here is an example of returning a response with a 404 status code, a JSON body,\nand a custom header:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'Deno.serve((req) => {\n  const body = JSON.stringify({ message: "NOT FOUND" });\n  return new Response(body, {\n    status: 404,\n    headers: {\n      "content-type": "application/json; charset=utf-8",\n    },\n  });\n});\n')),(0,a.kt)("p",null,'Response bodies can also be streams. Here is an example of a response that\nreturns a stream of "Hello, World!" repeated every second:'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'Deno.serve((req) => {\n  let timer: number;\n  const body = new ReadableStream({\n    async start(controller) {\n      timer = setInterval(() => {\n        controller.enqueue("Hello, World!\\n");\n      }, 1000);\n    },\n    cancel() {\n      clearInterval(timer);\n    },\n  });\n  return new Response(body.pipeThrough(new TextEncoderStream()), {\n    headers: {\n      "content-type": "text/plain; charset=utf-8",\n    },\n  });\n});\n')),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"\u2139\ufe0f Note the ",(0,a.kt)("inlineCode",{parentName:"p"},"cancel")," function here. This is called when the client hangs up the\nconnection. This is important to make sure that you handle this case, as\notherwise the server will keep queuing up messages forever, and eventually run\nout of memory.")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},'\u26a0\ufe0f Beware that the response body stream is "cancelled" when the client hangs up\nthe connection. Make sure to handle this case. This can surface itself as an\nerror in a ',(0,a.kt)("inlineCode",{parentName:"p"},"write()")," call on a ",(0,a.kt)("inlineCode",{parentName:"p"},"WritableStream")," object that is attached to the\nresponse body ",(0,a.kt)("inlineCode",{parentName:"p"},"ReadableStream")," object (for example through a\n",(0,a.kt)("inlineCode",{parentName:"p"},"TransformStream"),").")),(0,a.kt)("h3",{id:"https-support"},"HTTPS support"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"\u2139\ufe0f To use HTTPS, you will need a valid TLS certificate and a private key for\nyour server.")),(0,a.kt)("p",null,"To use HTTPS, pass two extra arguments in the options bag: ",(0,a.kt)("inlineCode",{parentName:"p"},"cert")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"key"),".\nThese are contents of the certificate and key files, respectively."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'Deno.serve({\n  port: 443,\n  cert: Deno.readTextFileSync("./cert.pem"),\n  key: Deno.readTextFileSync("./key.pem"),\n}, handler);\n')),(0,a.kt)("h3",{id:"http2-support"},"HTTP/2 support"),(0,a.kt)("p",null,'HTTP/2 support is "automatic" when using the HTTP server APIs with Deno. You\njust need to create your server, and the server will handle HTTP/1 or HTTP/2\nrequests seamlessly.'),(0,a.kt)("p",null,"HTTP/2 is also supported over cleartext with prior knowledge."),(0,a.kt)("h3",{id:"automatic-body-compression"},"Automatic body compression"),(0,a.kt)("p",null,"The HTTP server has built in automatic compression of response bodies. When a\nresponse is sent to a client, Deno determines if the response body can be safely\ncompressed. This compression happens within the internals of Deno, so it is fast\nand efficient."),(0,a.kt)("p",null,"Currently Deno supports gzip and brotli compression. A body is automatically\ncompressed if the following conditions are true:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The request has an\n",(0,a.kt)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding"},(0,a.kt)("inlineCode",{parentName:"a"},"Accept-Encoding")),"\nheader which indicates the requester supports ",(0,a.kt)("inlineCode",{parentName:"li"},"br")," for Brotli or ",(0,a.kt)("inlineCode",{parentName:"li"},"gzip"),". Deno\nwill respect the preference of the\n",(0,a.kt)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Glossary/Quality_values"},"quality value"),"\nin the header."),(0,a.kt)("li",{parentName:"ul"},"The response includes a\n",(0,a.kt)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type"},(0,a.kt)("inlineCode",{parentName:"a"},"Content-Type")),"\nwhich is considered compressible. (The list is derived from\n",(0,a.kt)("a",{parentName:"li",href:"https://github.com/jshttp/mime-db/blob/master/db.json"},(0,a.kt)("inlineCode",{parentName:"a"},"jshttp/mime-db"))," with\nthe actual list\n",(0,a.kt)("a",{parentName:"li",href:"https://github.com/denoland/deno/blob/v1.21.0/ext/http/compressible.rs"},"in the code"),".)"),(0,a.kt)("li",{parentName:"ul"},"The response body is greater than 64 bytes.")),(0,a.kt)("p",null,"When the response body is compressed, Deno will set the Content-Encoding header\nto reflect the encoding as well as ensure the Vary header is adjusted or added\nto indicate what request headers affected the response."),(0,a.kt)("p",null,"When is compression skipped? In addition to the logic above, there are a few\nother reasons why a response won\u2019t be compressed automatically:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The response contains a ",(0,a.kt)("inlineCode",{parentName:"li"},"Content-Encoding")," header. This indicates your server\nhas done some form of encoding already."),(0,a.kt)("li",{parentName:"ul"},"The response contains a\n",(0,a.kt)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Range"},(0,a.kt)("inlineCode",{parentName:"a"},"Content-Range")),"\nheader. This indicates that your server is responding to a range request,\nwhere the bytes and ranges are negotiated outside of the control of the\ninternals to Deno."),(0,a.kt)("li",{parentName:"ul"},"The response has a\n",(0,a.kt)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control"},(0,a.kt)("inlineCode",{parentName:"a"},"Cache-Control")),"\nheader which contains a\n",(0,a.kt)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#other"},(0,a.kt)("inlineCode",{parentName:"a"},"no-transform")),"\nvalue. This indicates that your server doesn\u2019t want Deno or any downstream\nproxies to modify the response.")),(0,a.kt)("h2",{id:"denoservehttp"},(0,a.kt)("inlineCode",{parentName:"h2"},"Deno.serveHttp")),(0,a.kt)("p",null,"We generally recommend that you use the ",(0,a.kt)("inlineCode",{parentName:"p"},"Deno.serve")," API described above, as it\nhandles all of the intricacies of parallel requests on a single connection,\nerror handling, and so on. However, if you are interested creating your own\nrobust and performant web servers in Deno, lower-level, ",(0,a.kt)("em",{parentName:"p"},"native")," HTTP server\nAPIs are available as of Deno 1.9 and later."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"\u26a0\ufe0f You should probably not be using this API, as it is not easy to get right.\nUse the ",(0,a.kt)("inlineCode",{parentName:"p"},"Deno.serve")," API instead.")),(0,a.kt)("h3",{id:"listening-for-a-connection"},"Listening for a connection"),(0,a.kt)("p",null,"In order to accept requests, first you need to listen for a connection on a\nnetwork port. To do this in Deno, you use ",(0,a.kt)("inlineCode",{parentName:"p"},"Deno.listen()"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"const server = Deno.listen({ port: 8080 });\n")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"\u2139\ufe0f When supplying a port, Deno assumes you are going to listen on a TCP socket\nas well as bind to the localhost. You can specify ",(0,a.kt)("inlineCode",{parentName:"p"},'transport: "tcp"')," to be\nmore explicit as well as provide an IP address or hostname in the ",(0,a.kt)("inlineCode",{parentName:"p"},"hostname"),"\nproperty as well.")),(0,a.kt)("p",null,"If there is an issue with opening the network port, ",(0,a.kt)("inlineCode",{parentName:"p"},"Deno.listen()")," will throw,\nso often in a server sense, you will want to wrap it in the ",(0,a.kt)("inlineCode",{parentName:"p"},"try ... catch"),"\nblock in order to handle exceptions, like the port already being in use."),(0,a.kt)("p",null,"You can also listen for a TLS connection (e.g. HTTPS) using ",(0,a.kt)("inlineCode",{parentName:"p"},"Deno.listenTls()"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'const server = Deno.listenTls({\n  port: 8443,\n  certFile: "localhost.crt",\n  keyFile: "localhost.key",\n  alpnProtocols: ["h2", "http/1.1"],\n});\n')),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"certFile")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"keyFile")," options are required and point to the appropriate\ncertificate and key files for the server. They are relative to the CWD for Deno.\nThe ",(0,a.kt)("inlineCode",{parentName:"p"},"alpnProtocols")," property is optional, but if you want to be able to support\nHTTP/2 on the server, you add the protocols here, as the protocol negotiation\nhappens during the TLS negotiation with the client and server."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"\u2139\ufe0f Generating SSL certificates is outside of the scope of this documentation.\nThere are many resources on the web which address this.")),(0,a.kt)("h3",{id:"handling-connections"},"Handling connections"),(0,a.kt)("p",null,"Once we are listening for a connection, we need to handle the connection. The\nreturn value of ",(0,a.kt)("inlineCode",{parentName:"p"},"Deno.listen()")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"Deno.listenTls()")," is a ",(0,a.kt)("inlineCode",{parentName:"p"},"Deno.Listener")," which\nis an async iterable which yields up ",(0,a.kt)("inlineCode",{parentName:"p"},"Deno.Conn")," connections as well as provide\na couple methods for handling connections."),(0,a.kt)("p",null,"To use it as an async iterable we would do something like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"const server = Deno.listen({ port: 8080 });\n\nfor await (const conn of server) {\n  // ...handle the connection...\n}\n")),(0,a.kt)("p",null,"Every connection made would yield up a ",(0,a.kt)("inlineCode",{parentName:"p"},"Deno.Conn")," assigned to ",(0,a.kt)("inlineCode",{parentName:"p"},"conn"),". Then\nfurther processing can be applied to the connection."),(0,a.kt)("p",null,"There is also the ",(0,a.kt)("inlineCode",{parentName:"p"},".accept()")," method on the listener which can be used:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"const server = Deno.listen({ port: 8080 });\n\nwhile (true) {\n  try {\n    const conn = await server.accept();\n    // ... handle the connection ...\n  } catch (err) {\n    // The listener has closed\n    break;\n  }\n}\n")),(0,a.kt)("p",null,"Whether using the async iterator or the ",(0,a.kt)("inlineCode",{parentName:"p"},".accept()")," method, exceptions can be\nthrown and robust production code should handle these using ",(0,a.kt)("inlineCode",{parentName:"p"},"try ... catch"),"\nblocks. Especially when it comes to accepting TLS connections, there can be many\nconditions, like invalid or unknown certificates which can be surfaced on the\nlistener and might need handling in the user code."),(0,a.kt)("p",null,"A listener also has a ",(0,a.kt)("inlineCode",{parentName:"p"},".close()")," method which can be used to close the listener."),(0,a.kt)("h3",{id:"serving-http"},"Serving HTTP"),(0,a.kt)("p",null,"Once a connection is accepted, you can use ",(0,a.kt)("inlineCode",{parentName:"p"},"Deno.serveHttp()")," to handle HTTP\nrequests and responses on the connection. ",(0,a.kt)("inlineCode",{parentName:"p"},"Deno.serveHttp()")," returns a\n",(0,a.kt)("inlineCode",{parentName:"p"},"Deno.HttpConn"),". A ",(0,a.kt)("inlineCode",{parentName:"p"},"Deno.HttpConn")," is like a ",(0,a.kt)("inlineCode",{parentName:"p"},"Deno.Listener")," in that requests\nthe connection receives from the client are asynchronously yielded up as a\n",(0,a.kt)("inlineCode",{parentName:"p"},"Deno.RequestEvent"),"."),(0,a.kt)("p",null,"To deal with HTTP requests as async iterable it would look something like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"const server = Deno.listen({ port: 8080 });\n\nfor await (const conn of server) {\n  (async () => {\n    const httpConn = Deno.serveHttp(conn);\n    for await (const requestEvent of httpConn) {\n      // ... handle requestEvent ...\n    }\n  })();\n}\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"Deno.HttpConn")," also has the method ",(0,a.kt)("inlineCode",{parentName:"p"},".nextRequest()")," which can be used to\nawait the next request. It would look something like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"const server = Deno.listen({ port: 8080 });\n\nwhile (true) {\n  try {\n    const conn = await server.accept();\n    (async () => {\n      const httpConn = Deno.serveHttp(conn);\n      while (true) {\n        try {\n          const requestEvent = await httpConn.nextRequest();\n          // ... handle requestEvent ...\n        } catch (err) {\n          // the connection has finished\n          break;\n        }\n      }\n    })();\n  } catch (err) {\n    // The listener has closed\n    break;\n  }\n}\n")),(0,a.kt)("p",null,'Note that in both cases we are using an IIFE to create an inner function to deal\nwith each connection. If we awaited the HTTP requests in the same function scope\nas the one we were receiving the connections, we would be blocking accepting\nadditional connections, which would make it seem that our server was "frozen".\nIn practice, it might make more sense to have a separate function all together:'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"async function handle(conn: Deno.Conn) {\n  const httpConn = Deno.serveHttp(conn);\n  for await (const requestEvent of httpConn) {\n    // ... handle requestEvent\n  }\n}\n\nconst server = Deno.listen({ port: 8080 });\n\nfor await (const conn of server) {\n  handle(conn);\n}\n")),(0,a.kt)("p",null,"In the examples from this point on, we will focus on what would occur within an\nexample ",(0,a.kt)("inlineCode",{parentName:"p"},"handle()"),' function and remove the listening and connection\n"boilerplate".'),(0,a.kt)("h4",{id:"http-requests-and-responses"},"HTTP Requests and Responses"),(0,a.kt)("p",null,"HTTP requests and responses in Deno are essentially the inverse of web standard\n",(0,a.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API"},"Fetch API"),". The\nDeno HTTP Server API and the Fetch API leverage the\n",(0,a.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/API/Request"},(0,a.kt)("inlineCode",{parentName:"a"},"Request"))," and\n",(0,a.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/API/Response"},(0,a.kt)("inlineCode",{parentName:"a"},"Response"))," object\nclasses. So if you are familiar with the Fetch API you just need to flip them\naround in your mind and now it is a server API."),(0,a.kt)("p",null,"As mentioned above, a ",(0,a.kt)("inlineCode",{parentName:"p"},"Deno.HttpConn")," asynchronously yields up\n",(0,a.kt)("inlineCode",{parentName:"p"},"Deno.RequestEvent"),"s. These request events contain a ",(0,a.kt)("inlineCode",{parentName:"p"},".request")," property and a\n",(0,a.kt)("inlineCode",{parentName:"p"},".respondWith()")," method."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},".request")," property is an instance of the ",(0,a.kt)("inlineCode",{parentName:"p"},"Request")," class with the\ninformation about the request. For example, if we wanted to know what URL path\nwas being requested, we would do something like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"async function handle(conn: Deno.Conn) {\n  const httpConn = Deno.serveHttp(conn);\n  for await (const requestEvent of httpConn) {\n    const url = new URL(requestEvent.request.url);\n    console.log(`path: ${url.pathname}`);\n  }\n}\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},".respondWith()")," method is how we complete a request. The method takes\neither a ",(0,a.kt)("inlineCode",{parentName:"p"},"Response")," object or a ",(0,a.kt)("inlineCode",{parentName:"p"},"Promise")," which resolves with a ",(0,a.kt)("inlineCode",{parentName:"p"},"Response"),'\nobject. Responding with a basic "hello world" would look like this:'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'async function handle(conn: Deno.Conn) {\n  const httpConn = Deno.serveHttp(conn);\n  for await (const requestEvent of httpConn) {\n    await requestEvent.respondWith(\n      new Response("hello world", {\n        status: 200,\n      }),\n    );\n  }\n}\n')),(0,a.kt)("p",null,"Note that we awaited the ",(0,a.kt)("inlineCode",{parentName:"p"},".respondWith()")," method. It isn't required, but in\npractice any errors in processing the response will cause the promise returned\nfrom the method to be rejected, like if the client disconnected before all the\nresponse could be sent. While there may not be anything your application needs\nto do, not handling the rejection will cause an \"unhandled rejection\" to occur\nwhich will terminate the Deno process, which isn't so good for a server. In\naddition, you might want to await the promise returned in order to determine\nwhen to do any cleanup from for the request/response cycle."),(0,a.kt)("p",null,"The web standard ",(0,a.kt)("inlineCode",{parentName:"p"},"Response")," object is pretty powerful, allowing easy creation of\ncomplex and rich responses to a client, and Deno strives to provide a ",(0,a.kt)("inlineCode",{parentName:"p"},"Response"),"\nobject that as closely matches the web standard as possible, so if you are\nwondering how to send a particular response, checkout the documentation for the\nweb standard\n",(0,a.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/API/Response"},(0,a.kt)("inlineCode",{parentName:"a"},"Response")),"."),(0,a.kt)("h3",{id:"http2-support-1"},"HTTP/2 Support"),(0,a.kt)("p",null,"HTTP/2 support is effectively transparent within the Deno runtime. Typically\nHTTP/2 is negotiated between a client and a server during the TLS connection\nsetup via\n",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation"},"ALPN"),". To\nenable this, you need to provide the protocols you want to support when you\nstart listening via the ",(0,a.kt)("inlineCode",{parentName:"p"},"alpnProtocols")," property. This will enable the\nnegotiation to occur when the connection is made. For example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'const server = Deno.listenTls({\n  port: 8443,\n  certFile: "localhost.crt",\n  keyFile: "localhost.key",\n  alpnProtocols: ["h2", "http/1.1"],\n});\n')),(0,a.kt)("p",null,"The protocols are provided in order of preference. In practice, the only two\nprotocols that are supported currently are HTTP/2 and HTTP/1.1 which are\nexpressed as ",(0,a.kt)("inlineCode",{parentName:"p"},"h2")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"http/1.1"),"."),(0,a.kt)("p",null,"Currently Deno does not support upgrading a plain-text HTTP/1.1 connection to an\nHTTP/2 cleartext connection via the ",(0,a.kt)("inlineCode",{parentName:"p"},"Upgrade")," header (see:\n",(0,a.kt)("a",{parentName:"p",href:"https://github.com/denoland/deno/issues/10275"},"#10275"),"), so therefore HTTP/2\nsupport is only available via a TLS/HTTPS connection."),(0,a.kt)("h3",{id:"serving-websockets"},"Serving WebSockets"),(0,a.kt)("p",null,"Deno can upgrade incoming HTTP requests to a WebSocket. This allows you to\nhandle WebSocket endpoints on your HTTP servers."),(0,a.kt)("p",null,"To upgrade an incoming ",(0,a.kt)("inlineCode",{parentName:"p"},"Request")," to a WebSocket you use the\n",(0,a.kt)("inlineCode",{parentName:"p"},"Deno.upgradeWebSocket")," function. This returns an object consisting of a\n",(0,a.kt)("inlineCode",{parentName:"p"},"Response")," and a web standard ",(0,a.kt)("inlineCode",{parentName:"p"},"WebSocket")," object. The returned response should\nbe used to respond to the incoming request using the ",(0,a.kt)("inlineCode",{parentName:"p"},"respondWith")," method. Only\nonce ",(0,a.kt)("inlineCode",{parentName:"p"},"respondWith")," is called with the returned response, the WebSocket is\nactivated and can be used."),(0,a.kt)("p",null,"Because the WebSocket protocol is symmetrical, the ",(0,a.kt)("inlineCode",{parentName:"p"},"WebSocket")," object is\nidentical to the one that can be used for client side communication.\nDocumentation for it can be found\n",(0,a.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/API/WebSocket"},"on MDN"),"."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Note: We are aware that this API can be challenging to use, and are planning\nto switch to\n",(0,a.kt)("a",{parentName:"p",href:"https://github.com/ricea/websocketstream-explainer/blob/master/README.md"},(0,a.kt)("inlineCode",{parentName:"a"},"WebSocketStream")),"\nonce it is stabilized and ready for use.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'async function handle(conn: Deno.Conn) {\n  const httpConn = Deno.serveHttp(conn);\n  for await (const requestEvent of httpConn) {\n    await requestEvent.respondWith(handleReq(requestEvent.request));\n  }\n}\n\nfunction handleReq(req: Request): Response {\n  const upgrade = req.headers.get("upgrade") || "";\n  if (upgrade.toLowerCase() != "websocket") {\n    return new Response("request isn\'t trying to upgrade to websocket.");\n  }\n  const { socket, response } = Deno.upgradeWebSocket(req);\n  socket.onopen = () => console.log("socket opened");\n  socket.onmessage = (e) => {\n    console.log("socket message:", e.data);\n    socket.send(new Date().toString());\n  };\n  socket.onerror = (e) => console.log("socket errored:", e);\n  socket.onclose = () => console.log("socket closed");\n  return response;\n}\n')),(0,a.kt)("p",null,"WebSockets are only supported on HTTP/1.1 for now. The connection the WebSocket\nwas created on can not be used for HTTP traffic after a WebSocket upgrade has\nbeen performed."))}h.isMDXComponent=!0}}]);