"use strict";(self.webpackChunkdeno_docs=self.webpackChunkdeno_docs||[]).push([[9316],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),m=p(n),c=o,h=m["".concat(l,".").concat(c)]||m[c]||d[c]||r;return n?a.createElement(h,s(s({ref:t},u),{},{components:n})):a.createElement(h,s({ref:t},u))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,s=new Array(r);s[0]=c;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[m]="string"==typeof e?e:o,s[1]=i;for(var p=2;p<r;p++)s[p]=n[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},20647:(e,t,n)=>{n.d(t,{ZP:()=>i});var a=n(87462),o=(n(67294),n(3905));const r={toc:[]},s="wrapper";function i(e){let{components:t,...n}=e;return(0,o.kt)(s,(0,a.Z)({},r,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("admonition",{title:"Deno KV is currently in beta",type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"Deno KV and related cloud primitive APIs like queues and cron are currently\n",(0,o.kt)("strong",{parentName:"p"},"experimental")," and ",(0,o.kt)("strong",{parentName:"p"},"subject to change"),". While we do our best to ensure data\ndurability, data loss is possible, especially around Deno updates."),(0,o.kt)("p",{parentName:"admonition"},"Deno programs that use KV require the ",(0,o.kt)("inlineCode",{parentName:"p"},"--unstable")," flag when launching the\nprogram, as shown below:"),(0,o.kt)("pre",{parentName:"admonition"},(0,o.kt)("code",{parentName:"pre",className:"language-sh"},"deno run -A --unstable my_kv_code.ts\n"))))}i.isMDXComponent=!0},11940:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>c,frontMatter:()=>s,metadata:()=>l,toc:()=>u});var a=n(87462),o=(n(67294),n(3905)),r=n(20647);const s={},i="Operations",l={unversionedId:"manual/operations",id:"manual/operations",title:"Operations",description:"The Deno KV API provides a set of operations that can be performed on the key",source:"@site/kv/manual/operations.mdx",sourceDirName:"manual",slug:"/manual/operations",permalink:"/kv/manual/operations",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"kvGuideHome",previous:{title:"Key Space",permalink:"/kv/manual/key_space"},next:{title:"Key Expiration",permalink:"/kv/manual/key_expiration"}},p={},u=[{value:"<code>get</code>",id:"get",level:2},{value:"<code>list</code>",id:"list",level:2},{value:"<code>set</code>",id:"set",level:2},{value:"<code>delete</code>",id:"delete",level:2},{value:"<code>sum</code>",id:"sum",level:2},{value:"<code>min</code>",id:"min",level:2},{value:"<code>max</code>",id:"max",level:2}],m={toc:u},d="wrapper";function c(e){let{components:t,...n}=e;return(0,o.kt)(d,(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"operations"},"Operations"),(0,o.kt)(r.ZP,{mdxType:"Admonition"}),(0,o.kt)("p",null,"The Deno KV API provides a set of operations that can be performed on the key\nspace."),(0,o.kt)("p",null,"There are two operations that read data from the store, and five operations that\nwrite data to the store."),(0,o.kt)("p",null,"Read operations can either be performed in strong or eventual consistency mode.\nStrong consistency mode guarantees that the read operation will return the most\nrecently written value. Eventual consistency mode may return a stale value, but\nis faster."),(0,o.kt)("p",null,"Write operations are always performed in strong consistency mode."),(0,o.kt)("h2",{id:"get"},(0,o.kt)("inlineCode",{parentName:"h2"},"get")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"get")," operation returns the value and versionstamp associated with a given\nkey. If a value does not exist, get returns a ",(0,o.kt)("inlineCode",{parentName:"p"},"null")," value and versionstamp."),(0,o.kt)("p",null,"There are two APIs that can be used to perform a ",(0,o.kt)("inlineCode",{parentName:"p"},"get")," operation. The\n",(0,o.kt)("a",{parentName:"p",href:"https://deno.land/api?s=Deno.Kv&p=prototype.get&unstable"},(0,o.kt)("inlineCode",{parentName:"a"},"Deno.Kv.prototype.get(key, options?)"))," API, which can be used to read a\nsingle key, and the ",(0,o.kt)("a",{parentName:"p",href:"https://deno.land/api?s=Deno.Kv&p=prototype.getMany&unstable"},(0,o.kt)("inlineCode",{parentName:"a"},"Deno.Kv.prototype.getMany(keys, options?)"))," API,\nwhich can be used to read multiple keys at once."),(0,o.kt)("p",null,'Get operations are performed as a "snapshot read" in all consistency modes. This\nmeans that when retrieving multiple keys at once, the values returned will be\nconsistent with each other.'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'const res = await kv.get<string>(["config"]);\nconsole.log(res); // { key: ["config"], value: "value", versionstamp: "000002fa526aaccb0000" }\n\nconst res = await kv.get<string>(["config"], { consistency: "eventual" });\nconsole.log(res); // { key: ["config"], value: "value", versionstamp: "000002fa526aaccb0000" }\n\nconst [res1, res2, res3] = await kv.getMany<[string, string, string]>([\n  ["users", "sam"],\n  ["users", "taylor"],\n  ["users", "alex"],\n]);\nconsole.log(res1); // { key: ["users", "sam"], value: "sam", versionstamp: "00e0a2a0f0178b270000" }\nconsole.log(res2); // { key: ["users", "taylor"], value: "taylor", versionstamp: "0059e9035e5e7c5e0000" }\nconsole.log(res3); // { key: ["users", "alex"], value: "alex", versionstamp: "00a44a3c3e53b9750000" }\n')),(0,o.kt)("h2",{id:"list"},(0,o.kt)("inlineCode",{parentName:"h2"},"list")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"list")," operation returns a list of keys that match a given selector. The\nassociated values and versionstamps for these keys are also returned. There are\n2 different selectors that can be used to filter the keys matched."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"prefix")," selector matches all keys that start with the given prefix key\nparts, but not inclusive of an exact match of the key. The prefix selector may\noptionally be given a ",(0,o.kt)("inlineCode",{parentName:"p"},"start")," OR ",(0,o.kt)("inlineCode",{parentName:"p"},"end")," key to limit the range of keys returned.\nThe ",(0,o.kt)("inlineCode",{parentName:"p"},"start")," key is inclusive, and the ",(0,o.kt)("inlineCode",{parentName:"p"},"end")," key is exclusive."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"range")," selector matches all keys that are lexographically between the given\n",(0,o.kt)("inlineCode",{parentName:"p"},"start")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"end")," keys. The ",(0,o.kt)("inlineCode",{parentName:"p"},"start")," key is inclusive, and the ",(0,o.kt)("inlineCode",{parentName:"p"},"end")," key is\nexclusive."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Note: In the case of the prefix selector, the ",(0,o.kt)("inlineCode",{parentName:"p"},"prefix")," key must consist only\nof full (not partial) key parts. For example, if the key ",(0,o.kt)("inlineCode",{parentName:"p"},'["foo", "bar"]'),"\nexists in the store, then the prefix selector ",(0,o.kt)("inlineCode",{parentName:"p"},'["foo"]')," will match it, but the\nprefix selector ",(0,o.kt)("inlineCode",{parentName:"p"},'["f"]')," will not.")),(0,o.kt)("p",null,"The list operation may optionally be given a ",(0,o.kt)("inlineCode",{parentName:"p"},"limit")," to limit the number of keys\nreturned."),(0,o.kt)("p",null,"List operations can be performed using the\n",(0,o.kt)("a",{parentName:"p",href:"https://deno.land/api?s=Deno.Kv&p=prototype.list&unstable"},(0,o.kt)("inlineCode",{parentName:"a"},"Deno.Kv.prototype.list<string>(selector, options?)"))," method. This method\nreturns a ",(0,o.kt)("inlineCode",{parentName:"p"},"Deno.KvListIterator")," that can be used to iterate over the keys\nreturned. This is an async iterator, and can be used with ",(0,o.kt)("inlineCode",{parentName:"p"},"for await")," loops."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'// Return all users\nconst iter = kv.list<string>({ prefix: ["users"] });\nconst users = [];\nfor await (const res of iter) users.push(res);\nconsole.log(users[0]); // { key: ["users", "alex"], value: "alex", versionstamp: "00a44a3c3e53b9750000" }\nconsole.log(users[1]); // { key: ["users", "sam"], value: "sam", versionstamp: "00e0a2a0f0178b270000" }\nconsole.log(users[2]); // { key: ["users", "taylor"], value: "taylor", versionstamp: "0059e9035e5e7c5e0000" }\n\n// Return the first 2 users\nconst iter = kv.list<string>({ prefix: ["users"] }, { limit: 2 });\nconst users = [];\nfor await (const res of iter) users.push(res);\nconsole.log(users[0]); // { key: ["users", "alex"], value: "alex", versionstamp: "00a44a3c3e53b9750000" }\nconsole.log(users[1]); // { key: ["users", "sam"], value: "sam", versionstamp: "00e0a2a0f0178b270000" }\n\n// Return all users lexicographically after "taylor"\nconst iter = kv.list<string>({ prefix: ["users"], start: ["users", "taylor"] });\nconst users = [];\nfor await (const res of iter) users.push(res);\nconsole.log(users[0]); // { key: ["users", "taylor"], value: "taylor", versionstamp: "0059e9035e5e7c5e0000" }\n\n// Return all users lexicographically before "taylor"\nconst iter = kv.list<string>({ prefix: ["users"], end: ["users", "taylor"] });\nconst users = [];\nfor await (const res of iter) users.push(res);\nconsole.log(users[0]); // { key: ["users", "alex"], value: "alex", versionstamp: "00a44a3c3e53b9750000" }\nconsole.log(users[1]); // { key: ["users", "sam"], value: "sam", versionstamp: "00e0a2a0f0178b270000" }\n\n// Return all users starting with characters between "a" and "n"\nconst iter = kv.list<string>({ start: ["users", "a"], end: ["users", "n"] });\nconst users = [];\nfor await (const res of iter) users.push(res);\nconsole.log(users[0]); // { key: ["users", "alex"], value: "alex", versionstamp: "00a44a3c3e53b9750000" }\n')),(0,o.kt)("p",null,"The list operation reads data from the store in batches. The size of each batch\ncan be controlled using the ",(0,o.kt)("inlineCode",{parentName:"p"},"batchSize")," option. The default batch size is 500\nkeys. Data within a batch is read in a single snapshot read, so the values are\nconsistent with each other. Consistency modes apply to each batch of data read.\nAcross batches, data is not consistent. The borders between batches is not\nvisible from the API as the iterator returns individual keys."),(0,o.kt)("p",null,"The list operation can be performed in reverse order by setting the ",(0,o.kt)("inlineCode",{parentName:"p"},"reverse"),"\noption to ",(0,o.kt)("inlineCode",{parentName:"p"},"true"),". This will return the keys in lexicographically descending\norder. The ",(0,o.kt)("inlineCode",{parentName:"p"},"start")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"end")," keys are still inclusive and exclusive\nrespectively, and are still interpreted as lexicographically ascending."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'// Return all users in reverse order, ending with "sam"\nconst iter = kv.list<string>({ prefix: ["users"], start: ["users", "sam"] }, {\n  reverse: true,\n});\nconst users = [];\nfor await (const res of iter) users.push(res);\nconsole.log(users[0]); // { key: ["users", "taylor"], value: "taylor", versionstamp: "0059e9035e5e7c5e0000" }\nconsole.log(users[1]); // { key: ["users", "sam"], value: "sam", versionstamp: "00e0a2a0f0178b270000" }\n')),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Note: in the above example we set the ",(0,o.kt)("inlineCode",{parentName:"p"},"start")," key to ",(0,o.kt)("inlineCode",{parentName:"p"},'["users", "sam"]'),", even\nthough the first key returned is ",(0,o.kt)("inlineCode",{parentName:"p"},'["users", "taylor"]'),". This is because the\n",(0,o.kt)("inlineCode",{parentName:"p"},"start")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"end")," keys are always evaluated in lexicographically ascending\norder, even when the list operation is performed in reverse order (which\nreturns the keys in lexicographically descending order).")),(0,o.kt)("h2",{id:"set"},(0,o.kt)("inlineCode",{parentName:"h2"},"set")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"set")," operation sets the value of a key in the store. If the key does not\nexist, it is created. If the key already exists, its value is overwritten."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"set")," operation can be performed using the\n",(0,o.kt)("a",{parentName:"p",href:"https://deno.land/api?s=Deno.Kv&p=prototype.set&unstable"},(0,o.kt)("inlineCode",{parentName:"a"},"Deno.Kv.prototype.set(key, value)"))," method. This method returns a\n",(0,o.kt)("inlineCode",{parentName:"p"},"Promise")," that resolves to a ",(0,o.kt)("inlineCode",{parentName:"p"},"Deno.KvCommitResult")," object, which contains the\n",(0,o.kt)("inlineCode",{parentName:"p"},"versionstamp")," of the commit."),(0,o.kt)("p",null,"Set operations are always performed in strong consistency mode."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'const res = await kv.set(["users", "alex"], "alex");\nconsole.log(res.versionstamp); // "00a44a3c3e53b9750000"\n')),(0,o.kt)("h2",{id:"delete"},(0,o.kt)("inlineCode",{parentName:"h2"},"delete")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"delete")," operation deletes a key from the store. If the key does not exist,\nthe operation is a no-op."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"delete")," operation can be performed using the\n",(0,o.kt)("a",{parentName:"p",href:"https://deno.land/api?s=Deno.Kv&p=prototype.delete&unstable"},(0,o.kt)("inlineCode",{parentName:"a"},"Deno.Kv.prototype.delete(key)"))," method."),(0,o.kt)("p",null,"Delete operations are always performed in strong consistency mode."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'await kv.delete(["users", "alex"]);\n')),(0,o.kt)("h2",{id:"sum"},(0,o.kt)("inlineCode",{parentName:"h2"},"sum")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"sum")," operation atomically adds a value to a key in the store. If the key\ndoes not exist, it is created with the value of the sum. If the key already\nexists, its value is added to the sum."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"sum")," operation can only be performed as part of an atomic operation. The\n",(0,o.kt)("a",{parentName:"p",href:"https://deno.land/api?s=Deno.AtomicOperation&p=prototype.mutate&unstable"},(0,o.kt)("inlineCode",{parentName:"a"},'Deno.AtomicOperation.prototype.mutate({ type: "sum", value })'))," method\ncan be used to add a sum mutation to an atomic operation."),(0,o.kt)("p",null,"The sum operation can only be performed on values of type ",(0,o.kt)("inlineCode",{parentName:"p"},"Deno.KvU64"),". Both the\noperand and the value in the store must be of type ",(0,o.kt)("inlineCode",{parentName:"p"},"Deno.KvU64"),"."),(0,o.kt)("p",null,"If the new value of the key is greater than ",(0,o.kt)("inlineCode",{parentName:"p"},"2^64 - 1")," or less than ",(0,o.kt)("inlineCode",{parentName:"p"},"0"),", the sum\noperation wraps around. For example, if the value in the store is ",(0,o.kt)("inlineCode",{parentName:"p"},"2^64 - 1")," and\nthe operand is ",(0,o.kt)("inlineCode",{parentName:"p"},"1"),", the new value will be ",(0,o.kt)("inlineCode",{parentName:"p"},"0"),"."),(0,o.kt)("p",null,"Sum operations are always performed in strong consistency mode."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'await kv.atomic()\n  .mutate({\n    type: "sum",\n    key: ["accounts", "alex"],\n    value: new Deno.KvU64(100n),\n  })\n  .commit();\n')),(0,o.kt)("h2",{id:"min"},(0,o.kt)("inlineCode",{parentName:"h2"},"min")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"min")," operation atomically sets a key to the minimum of its current value\nand a given value. If the key does not exist, it is created with the given\nvalue. If the key already exists, its value is set to the minimum of its current\nvalue and the given value."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"min")," operation can only be performed as part of an atomic operation. The\n",(0,o.kt)("a",{parentName:"p",href:"https://deno.land/api?s=Deno.AtomicOperation&p=prototype.mutate&unstable"},(0,o.kt)("inlineCode",{parentName:"a"},'Deno.AtomicOperation.prototype.mutate({ type: "min", value })'))," method\ncan be used to add a min mutation to an atomic operation."),(0,o.kt)("p",null,"The min operation can only be performed on values of type ",(0,o.kt)("inlineCode",{parentName:"p"},"Deno.KvU64"),". Both the\noperand and the value in the store must be of type ",(0,o.kt)("inlineCode",{parentName:"p"},"Deno.KvU64"),"."),(0,o.kt)("p",null,"Min operations are always performed in strong consistency mode."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'await kv.atomic()\n  .mutate({\n    type: "min",\n    key: ["accounts", "alex"],\n    value: new Deno.KvU64(100n),\n  })\n  .commit();\n')),(0,o.kt)("h2",{id:"max"},(0,o.kt)("inlineCode",{parentName:"h2"},"max")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"max")," operation atomically sets a key to the maximum of its current value\nand a given value. If the key does not exist, it is created with the given\nvalue. If the key already exists, its value is set to the maximum of its current\nvalue and the given value."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"max")," operation can only be performed as part of an atomic operation. The\n",(0,o.kt)("a",{parentName:"p",href:"https://deno.land/api?s=Deno.AtomicOperation&p=prototype.mutate&unstable"},(0,o.kt)("inlineCode",{parentName:"a"},'Deno.AtomicOperation.prototype.mutate({ type: "max", value })'))," method\ncan be used to add a max mutation to an atomic operation."),(0,o.kt)("p",null,"The max operation can only be performed on values of type ",(0,o.kt)("inlineCode",{parentName:"p"},"Deno.KvU64"),". Both the\noperand and the value in the store must be of type ",(0,o.kt)("inlineCode",{parentName:"p"},"Deno.KvU64"),"."),(0,o.kt)("p",null,"Max operations are always performed in strong consistency mode."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'await kv.atomic()\n  .mutate({\n    type: "max",\n    key: ["accounts", "alex"],\n    value: new Deno.KvU64(100n),\n  })\n  .commit();\n')))}c.isMDXComponent=!0}}]);