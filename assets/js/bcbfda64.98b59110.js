"use strict";(self.webpackChunkdeno_docs=self.webpackChunkdeno_docs||[]).push([[7072],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>h});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var c=r.createContext({}),l=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},u=function(e){var n=l(e.components);return r.createElement(c.Provider,{value:n},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),p=l(t),d=a,h=p["".concat(c,".").concat(d)]||p[d]||m[d]||o;return t?r.createElement(h,s(s({ref:n},u),{},{components:t})):r.createElement(h,s({ref:n},u))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,s=new Array(o);s[0]=d;var i={};for(var c in n)hasOwnProperty.call(n,c)&&(i[c]=n[c]);i.originalType=e,i[p]="string"==typeof e?e:a,s[1]=i;for(var l=2;l<o;l++)s[l]=t[l];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},20647:(e,n,t)=>{t.d(n,{ZP:()=>i});var r=t(87462),a=(t(67294),t(3905));const o={toc:[]},s="wrapper";function i(e){let{components:n,...t}=e;return(0,a.kt)(s,(0,r.Z)({},o,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("admonition",{title:"Deno KV is currently in beta",type:"caution"},(0,a.kt)("p",{parentName:"admonition"},"Deno KV and related cloud primitive APIs like queues and cron are currently\n",(0,a.kt)("strong",{parentName:"p"},"experimental")," and ",(0,a.kt)("strong",{parentName:"p"},"subject to change"),". While we do our best to ensure data\ndurability, data loss is possible, especially around Deno updates."),(0,a.kt)("p",{parentName:"admonition"},"Deno programs that use KV require the ",(0,a.kt)("inlineCode",{parentName:"p"},"--unstable")," flag when launching the\nprogram, as shown below:"),(0,a.kt)("pre",{parentName:"admonition"},(0,a.kt)("code",{parentName:"pre",className:"language-sh"},"deno run -A --unstable my_kv_code.ts\n"))))}i.isMDXComponent=!0},69563:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>s,metadata:()=>c,toc:()=>u});var r=t(87462),a=(t(67294),t(3905)),o=t(20647);const s={},i="Transactions",c={unversionedId:"manual/transactions",id:"manual/transactions",title:"Transactions",description:"The Deno KV store utilizes optimistic concurrency control transactions rather",source:"@site/kv/manual/transactions.mdx",sourceDirName:"manual",slug:"/manual/transactions",permalink:"/kv/manual/transactions",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"kvGuideHome",previous:{title:"Secondary Indexes",permalink:"/kv/manual/secondary_indexes"},next:{title:"Using Queues",permalink:"/kv/manual/queue_overview"}},l={},u=[],p={toc:u},m="wrapper";function d(e){let{components:n,...t}=e;return(0,a.kt)(m,(0,r.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"transactions"},"Transactions"),(0,a.kt)(o.ZP,{mdxType:"Admonition"}),(0,a.kt)("p",null,"The Deno KV store utilizes ",(0,a.kt)("em",{parentName:"p"},"optimistic concurrency control transactions")," rather\nthan ",(0,a.kt)("em",{parentName:"p"},"interactive transactions")," like many SQL systems like PostgreSQL or MySQL.\nThis approach employs versionstamps, which represent the current version of a\nvalue for a given key, to manage concurrent access to shared resources without\nusing locks. When a read operation occurs, the system returns a versionstamp for\nthe associated key in addition to the value."),(0,a.kt)("p",null,"To execute a transaction, one performs an atomic operations that can consist of\nmultiple mutation actions (like set or delete). Along with these actions,\nkey+versionstamp pairs are provided as a condition for the transaction's\nsuccess. The optimistic concurrency control transaction will only commit if the\nspecified versionstamps match the current version for the values in the database\nfor the corresponding keys. This transaction model ensures data consistency and\nintegrity while allowing concurrent interactions within the Deno KV store."),(0,a.kt)("p",null,"Because OCC transactions are optimistic, they can fail on commit because the\nversion constraints specified in the atomic operation were violated. This occurs\nwhen an agent updates a key used within the transaction between read and commit.\nWhen this happens, the agent performing the transaction must retry the\ntransaction."),(0,a.kt)("p",null,"To illustrate how to use OCC transactions with Deno KV, this example shows how\nto implement a ",(0,a.kt)("inlineCode",{parentName:"p"},"transferFunds(from: string, to: string, amount: number)"),"\nfunction for an account ledger. The account ledger stores the balance for each\naccount in the key-value store. The keys are prefixed by ",(0,a.kt)("inlineCode",{parentName:"p"},'"account"'),", followed\nby the account identifier: ",(0,a.kt)("inlineCode",{parentName:"p"},'["account", "alice"]'),". The value stored for each key\nis a number that represents the account balance."),(0,a.kt)("p",null,"Here's a step-by-step example of implementing this ",(0,a.kt)("inlineCode",{parentName:"p"},"transferFunds")," function:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"async function transferFunds(sender: string, receiver: string, amount: number) {\n  if (amount <= 0) throw new Error(\"Amount must be positive\");\n\n  // Construct the KV keys for the sender and receiver accounts.\n  const senderKey = [\"account\", sender];\n  const receiverKey = [\"account\", receiver];\n\n  // Retry the transaction until it succeeds.\n  let res = { ok: false };\n  while (!res.ok) {\n    // Read the current balance of both accounts.\n    const [senderRes, receiverRes] = await kv.getMany([senderKey, receiverKey]);\n    if (senderRes.value === null) throw new Error(`Account ${sender} not found`);\n    if (receiverRes.value === null) throw new Error(`Account ${receiver} not found`);\n\n    const senderBalance = senderRes.value;\n    const receiverBalance = receiverRes.value;\n\n    // Ensure the sender has a sufficient balance to complete the transfer.\n    if (senderBalance < amount) {\n      throw new Error(\n        `Insufficient funds to transfer ${amount} from ${sender}`,\n      );\n    }\n\n    // Perform the transfer.\n    const newSenderBalance = senderBalance - amount;\n    const newReceiverBalance = receiverBalance + amount;\n\n    // Attempt to commit the transaction. `res` returns an object with\n    // `ok: false` if the transaction fails to commit due to a check failure\n    // (i.e. the versionstamp for a key has changed)\n    res = await kv.atomic()\n      .check(senderRes) // Ensure the sender's balance hasn't changed.\n      .check(receiverRes) // Ensure the receiver's balance hasn't changed.\n      .set(senderKey, newSenderBalance) // Update the sender's balance.\n      .set(receiverKey, newReceiverBalance) // Update the receiver's balance.\n      .commit();\n  }\n}\n")),(0,a.kt)("p",null,"In this example, the ",(0,a.kt)("inlineCode",{parentName:"p"},"transferFunds")," function reads the balances and\nversionstamps of both accounts, calculates the new balances after the transfer,\nand checks if there are sufficient funds in account A. It then performs an\natomic operation, setting the new balances with the versionstamp constraints. If\nthe transaction is successful, the loop exits. If the version constraints are\nviolated, the transaction fails, and the loop retries the transaction until it\nsucceeds."))}d.isMDXComponent=!0}}]);