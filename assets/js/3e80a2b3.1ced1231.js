"use strict";(self.webpackChunkdeno_docs=self.webpackChunkdeno_docs||[]).push([[4672],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>y});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),u=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},c=function(e){var n=u(e.components);return a.createElement(l.Provider,{value:n},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),d=u(t),m=r,y=d["".concat(l,".").concat(m)]||d[m]||p[m]||i;return t?a.createElement(y,s(s({ref:n},c),{},{components:t})):a.createElement(y,s({ref:n},c))}));function y(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,s=new Array(i);s[0]=m;var o={};for(var l in n)hasOwnProperty.call(n,l)&&(o[l]=n[l]);o.originalType=e,o[d]="string"==typeof e?e:r,s[1]=o;for(var u=2;u<i;u++)s[u]=t[u];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},20647:(e,n,t)=>{t.d(n,{ZP:()=>o});var a=t(87462),r=(t(67294),t(3905));const i={toc:[]},s="wrapper";function o(e){let{components:n,...t}=e;return(0,r.kt)(s,(0,a.Z)({},i,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("admonition",{title:"Deno KV is currently in beta",type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Deno KV and related cloud primitive APIs like queues and cron are currently\n",(0,r.kt)("strong",{parentName:"p"},"experimental")," and ",(0,r.kt)("strong",{parentName:"p"},"subject to change"),". While we do our best to ensure data\ndurability, data loss is possible, especially around Deno updates."),(0,r.kt)("p",{parentName:"admonition"},"Deno programs that use KV require the ",(0,r.kt)("inlineCode",{parentName:"p"},"--unstable")," flag when launching the\nprogram, as shown below:"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"deno run -A --unstable my_kv_code.ts\n"))))}o.isMDXComponent=!0},85141:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>o,default:()=>m,frontMatter:()=>s,metadata:()=>l,toc:()=>c});var a=t(87462),r=(t(67294),t(3905)),i=t(20647);const s={},o="Secondary Indexes",l={unversionedId:"manual/secondary_indexes",id:"manual/secondary_indexes",title:"Secondary Indexes",description:"Key-value stores like Deno KV organize data as collections of key-value pairs,",source:"@site/kv/manual/secondary_indexes.mdx",sourceDirName:"manual",slug:"/manual/secondary_indexes",permalink:"/kv/manual/secondary_indexes",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"kvGuideHome",previous:{title:"Key Expiration",permalink:"/kv/manual/key_expiration"},next:{title:"Transactions",permalink:"/kv/manual/transactions"}},u={},c=[{value:"Unique indexes (one-to-one)",id:"unique-indexes-one-to-one",level:2},{value:"Non-Unique Indexes (One-to-Many)",id:"non-unique-indexes-one-to-many",level:2}],d={toc:c},p="wrapper";function m(e){let{components:n,...t}=e;return(0,r.kt)(p,(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"secondary-indexes"},"Secondary Indexes"),(0,r.kt)(i.ZP,{mdxType:"Admonition"}),(0,r.kt)("p",null,"Key-value stores like Deno KV organize data as collections of key-value pairs,\nwhere each unique key is associated with a single value. This structure enables\neasy retrieval of values based on their keys but does not allow for querying\nbased on the values themselves. To overcome this constraint, you can create\nsecondary indexes, which store the same value under additional keys that include\n(part of) that value."),(0,r.kt)("p",null,"Maintaining consistency between primary and secondary keys is crucial when using\nsecondary indexes. If a value is updated at the primary key without updating the\nsecondary key, the data returned from a query targeting the secondary key will\nbe incorrect. To ensure that primary and secondary keys always represent the\nsame data, use atomic operations when inserting, updating, or deleting data.\nThis approach ensures that the group of mutation actions are executed as a\nsingle unit, and either all succeed or all fail, preventing inconsistencies."),(0,r.kt)("h2",{id:"unique-indexes-one-to-one"},"Unique indexes (one-to-one)"),(0,r.kt)("p",null,"Unique indexes have each key in the index associated with exactly one primary\nkey. For example, when storing user data and looking up users by both their\nunique IDs and email addresses, store user data under two separate keys: one for\nthe primary key (user ID) and another for the secondary index (email). This\nsetup allows querying users based on either their ID or their email. The\nsecondary index can also enforce uniqueness constraints on values in the store.\nIn the case of user data, use the index to ensure that each email address is\nassociated with only one user - in other words that emails are unique."),(0,r.kt)("p",null,"To implement a unique secondary index for this example, follow these steps:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Create a ",(0,r.kt)("inlineCode",{parentName:"p"},"User")," interface representing the data:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"interface User {\n  id: string;\n  name: string;\n  email: string;\n}\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Define an ",(0,r.kt)("inlineCode",{parentName:"p"},"insertUser")," function that stores user data at both the primary and\nsecondary keys:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},'async function insertUser(user: User) {\n  const primaryKey = ["users", user.id];\n  const byEmailKey = ["users_by_email", user.email];\n  const res = await kv.atomic()\n    .check({ key: primaryKey, versionstamp: null })\n    .check({ key: byEmailKey, versionstamp: null })\n    .set(primaryKey, user)\n    .set(byEmailKey, user)\n    .commit();\n  if (!res.ok) {\n    throw new TypeError("User with ID or email already exists");\n  }\n}\n')),(0,r.kt)("blockquote",{parentName:"li"},(0,r.kt)("p",{parentName:"blockquote"},"This function performs the insert using an atomic operation that checks\nthat no user with the same ID or email already exists. If either of these\nconstraints is violated, the insert fails and no data is modified."))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Define a ",(0,r.kt)("inlineCode",{parentName:"p"},"getUser")," function to retrieve a user by their ID:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},'async function getUser(id: string): Promise<User | null> {\n  const res = await kv.get<User>(["users", id]);\n  return res.value;\n}\n'))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Define a ",(0,r.kt)("inlineCode",{parentName:"p"},"getUserByEmail")," function to retrieve a user by their email address:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},'async function getUserByEmail(email: string): Promise<User | null> {\n  const res = await kv.get<User>(["users_by_email", email]);\n  return res.value;\n}\n')),(0,r.kt)("p",{parentName:"li"},"This function queries the store using the secondary key\n(",(0,r.kt)("inlineCode",{parentName:"p"},'["users_by_email", email]'),").")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Define a deleteUser function to delete users by their ID:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},'async function deleteUser(id: string) {\n  let res = { ok: false };\n  while (!res.ok) {\n    const getRes = await kv.get<User>(["users", id]);\n    if (getRes.value === null) return;\n    res = await kv.atomic()\n      .check(getRes)\n      .delete(["users", id])\n      .delete(["users_by_email", getRes.value.email])\n      .commit();\n  }\n}\n')),(0,r.kt)("blockquote",{parentName:"li"},(0,r.kt)("p",{parentName:"blockquote"},"This function first retrieves the user by their ID to get the users email\naddress. This is needed to retrieve the email that is needed to construct\nthe key for the secondary index for this user address. It then performs an\natomic operation that checks that the user in the database has not changed,\nand then deletes both the primary and secondary key pointing to the user\nvalue. If this fails (the user has been modified between query and delete),\nthe atomic operation aborts. The entire procedure is retried until the\ndelete succeeds."),(0,r.kt)("p",{parentName:"blockquote"},"The check is required to prevent race conditions where\nvalue may have been modified between the retrieve and delete. This race can\noccur if an update changes the user's email, because the secondary index\nmoves in this case. The delete of the secondary index then fails, because\nthe delete is targeting the old secondary index key.")))),(0,r.kt)("h2",{id:"non-unique-indexes-one-to-many"},"Non-Unique Indexes (One-to-Many)"),(0,r.kt)("p",null,"Non-unique indexes are secondary indexes where a single key can be associated\nwith multiple primary keys, allowing you to query for multiple items based on a\nshared attribute. For example, when querying users by their favorite color,\nimplement this using a non-unique secondary index. The favorite color is a\nnon-unique attribute since multiple users can have the same favorite color."),(0,r.kt)("p",null,"To implement a non-unique secondary index for this example, follow these steps:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Define the ",(0,r.kt)("inlineCode",{parentName:"p"},"User")," interface:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"interface User {\n  id: string;\n  name: string;\n  favoriteColor: string;\n}\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Define the ",(0,r.kt)("inlineCode",{parentName:"p"},"insertUser")," function:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'async function insertUser(user: User) {\n  const primaryKey = ["users", user.id];\n  const byColorKey = ["users_by_favorite_color", user.favoriteColor, user.id];\n  await kv.atomic()\n    .check({ key: primaryKey, versionstamp: null })\n    .set(primaryKey, user)\n    .set(byColorKey, user)\n    .commit();\n}\n'))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Define a function to retrieve users by their favorite color:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'async function getUsersByFavoriteColor(color: string): Promise<User[]> {\n  const iter = kv.list<User>({ prefix: ["users_by_favorite_color", color] });\n  const users = [];\n  for await (const { value } of iter) {\n    users.push(value);\n  }\n  return users;\n}\n')))),(0,r.kt)("p",null,"This example demonstrates the use of a non-unique secondary index,\n",(0,r.kt)("inlineCode",{parentName:"p"},"users_by_favorite_color"),", which allows querying users based on their favorite\ncolor. The primary key remains the user ",(0,r.kt)("inlineCode",{parentName:"p"},"id"),"."),(0,r.kt)("p",null,"The primary difference between the implementation of unique and non-unique\nindexes lies in the structure and organization of the secondary keys. In unique\nindexes, each secondary key is associated with exactly one primary key, ensuring\nthat the indexed attribute is unique across all records. In the case of\nnon-unique indexes, a single secondary key can be associated with multiple\nprimary keys, as the indexed attribute may be shared among multiple records. To\nachieve this, non-unique secondary keys are typically structured with an\nadditional unique identifier (e.g., primary key) as part of the key, allowing\nmultiple records with the same attribute to coexist without conflicts."))}m.isMDXComponent=!0}}]);