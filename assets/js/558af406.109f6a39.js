"use strict";(self.webpackChunkdeno_docs=self.webpackChunkdeno_docs||[]).push([[196],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),p=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(o.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,o=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),m=p(n),c=r,h=m["".concat(o,".").concat(c)]||m[c]||d[c]||s;return n?a.createElement(h,l(l({ref:t},u),{},{components:n})):a.createElement(h,l({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,l=new Array(s);l[0]=c;var i={};for(var o in t)hasOwnProperty.call(t,o)&&(i[o]=t[o]);i.originalType=e,i[m]="string"==typeof e?e:r,l[1]=i;for(var p=2;p<s;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},20206:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>d,frontMatter:()=>s,metadata:()=>i,toc:()=>p});var a=n(87462),r=(n(67294),n(3905));const s={},l="Mocking",i={unversionedId:"manual/basics/testing/mocking",id:"manual/basics/testing/mocking",title:"Mocking",description:"Test spies are function stand-ins that are used to assert if a function's",source:"@site/runtime/manual/basics/testing/mocking.md",sourceDirName:"manual/basics/testing",slug:"/manual/basics/testing/mocking",permalink:"/runtime/manual/basics/testing/mocking",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"runtimeGuideHome",previous:{title:"Test Coverage",permalink:"/runtime/manual/basics/testing/coverage"},next:{title:"Test Sanitizers",permalink:"/runtime/manual/basics/testing/sanitizers"}},o={},p=[{value:"Spying",id:"spying",level:2},{value:"Stubbing",id:"stubbing",level:2},{value:"Faking time",id:"faking-time",level:2}],u={toc:p},m="wrapper";function d(e){let{components:t,...n}=e;return(0,r.kt)(m,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"mocking"},"Mocking"),(0,r.kt)("p",null,"Test spies are function stand-ins that are used to assert if a function's\ninternal behavior matches expectations. Test spies on methods keep the original\nbehavior but allow you to test how the method is called and what it returns.\nTest stubs are an extension of test spies that also replaces the original\nmethod's behavior."),(0,r.kt)("h2",{id:"spying"},"Spying"),(0,r.kt)("p",null,"Say we have two functions, ",(0,r.kt)("inlineCode",{parentName:"p"},"square")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"multiply"),", if we want to assert that\nthe ",(0,r.kt)("inlineCode",{parentName:"p"},"multiply")," function is called during execution of the ",(0,r.kt)("inlineCode",{parentName:"p"},"square")," function we\nneed a way to spy on the ",(0,r.kt)("inlineCode",{parentName:"p"},"multiply")," function. There are a few ways to achieve\nthis with Spies, one is to have the ",(0,r.kt)("inlineCode",{parentName:"p"},"square")," function take the ",(0,r.kt)("inlineCode",{parentName:"p"},"multiply")," as a\nparameter."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// https://deno.land/std/testing/mock_examples/parameter_injection.ts\nexport function multiply(a: number, b: number): number {\n  return a * b;\n}\n\nexport function square(\n  multiplyFn: (a: number, b: number) => number,\n  value: number,\n): number {\n  return multiplyFn(value, value);\n}\n")),(0,r.kt)("p",null,"This way, we can call ",(0,r.kt)("inlineCode",{parentName:"p"},"square(multiply, value)")," in the application code or wrap\na spy function around the ",(0,r.kt)("inlineCode",{parentName:"p"},"multiply")," function and call\n",(0,r.kt)("inlineCode",{parentName:"p"},"square(multiplySpy, value)")," in the testing code."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'// https://deno.land/std/testing/mock_examples/parameter_injection_test.ts\nimport {\n  assertSpyCall,\n  assertSpyCalls,\n  spy,\n} from "https://deno.land/std@0.208.0/testing/mock.ts";\nimport { assertEquals } from "https://deno.land/std@0.208.0/assert/mod.ts";\nimport {\n  multiply,\n  square,\n} from "https://deno.land/std@0.208.0/testing/mock_examples/parameter_injection.ts";\n\nDeno.test("square calls multiply and returns results", () => {\n  const multiplySpy = spy(multiply);\n\n  assertEquals(square(multiplySpy, 5), 25);\n\n  // asserts that multiplySpy was called at least once and details about the first call.\n  assertSpyCall(multiplySpy, 0, {\n    args: [5, 5],\n    returned: 25,\n  });\n\n  // asserts that multiplySpy was only called once.\n  assertSpyCalls(multiplySpy, 1);\n});\n')),(0,r.kt)("p",null,"If you prefer not adding additional parameters for testing purposes only, you\ncan use spy to wrap a method on an object instead. In the following example, the\nexported ",(0,r.kt)("inlineCode",{parentName:"p"},"_internals")," object has the ",(0,r.kt)("inlineCode",{parentName:"p"},"multiply")," function we want to call as a\nmethod and the ",(0,r.kt)("inlineCode",{parentName:"p"},"square")," function calls ",(0,r.kt)("inlineCode",{parentName:"p"},"_internals.multiply")," instead of\n",(0,r.kt)("inlineCode",{parentName:"p"},"multiply"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// https://deno.land/std/testing/mock_examples/internals_injection.ts\nexport function multiply(a: number, b: number): number {\n  return a * b;\n}\n\nexport function square(value: number): number {\n  return _internals.multiply(value, value);\n}\n\nexport const _internals = { multiply };\n")),(0,r.kt)("p",null,"This way, we can call ",(0,r.kt)("inlineCode",{parentName:"p"},"square(value)")," in both the application code and testing\ncode. Then spy on the ",(0,r.kt)("inlineCode",{parentName:"p"},"multiply")," method on the ",(0,r.kt)("inlineCode",{parentName:"p"},"_internals")," object in the\ntesting code to be able to spy on how the ",(0,r.kt)("inlineCode",{parentName:"p"},"square")," function calls the ",(0,r.kt)("inlineCode",{parentName:"p"},"multiply"),"\nfunction."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'// https://deno.land/std/testing/mock_examples/internals_injection_test.ts\nimport {\n  assertSpyCall,\n  assertSpyCalls,\n  spy,\n} from "https://deno.land/std@0.208.0/testing/mock.ts";\nimport { assertEquals } from "https://deno.land/std@0.208.0/assert/mod.ts";\nimport {\n  _internals,\n  square,\n} from "https://deno.land/std@0.208.0/testing/mock_examples/internals_injection.ts";\n\nDeno.test("square calls multiply and returns results", () => {\n  const multiplySpy = spy(_internals, "multiply");\n\n  try {\n    assertEquals(square(5), 25);\n  } finally {\n    // unwraps the multiply method on the _internals object\n    multiplySpy.restore();\n  }\n\n  // asserts that multiplySpy was called at least once and details about the first call.\n  assertSpyCall(multiplySpy, 0, {\n    args: [5, 5],\n    returned: 25,\n  });\n\n  // asserts that multiplySpy was only called once.\n  assertSpyCalls(multiplySpy, 1);\n});\n')),(0,r.kt)("p",null,"One difference you may have noticed between these two examples is that in the\nsecond we call the ",(0,r.kt)("inlineCode",{parentName:"p"},"restore")," method on ",(0,r.kt)("inlineCode",{parentName:"p"},"multiplySpy")," function. That is needed to\nremove the spy wrapper from the ",(0,r.kt)("inlineCode",{parentName:"p"},"_internals")," object's ",(0,r.kt)("inlineCode",{parentName:"p"},"multiply")," method. The\n",(0,r.kt)("inlineCode",{parentName:"p"},"restore")," method is called in a finally block to ensure that it is restored\nwhether or not the assertion in the try block is successful. The ",(0,r.kt)("inlineCode",{parentName:"p"},"restore"),"\nmethod didn't need to be called in the first example because the ",(0,r.kt)("inlineCode",{parentName:"p"},"multiply"),"\nfunction was not modified in any way like the ",(0,r.kt)("inlineCode",{parentName:"p"},"_internals")," object was in the\nsecond example."),(0,r.kt)("h2",{id:"stubbing"},"Stubbing"),(0,r.kt)("p",null,"Say we have two functions, ",(0,r.kt)("inlineCode",{parentName:"p"},"randomMultiple")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"randomInt"),", if we want to\nassert that ",(0,r.kt)("inlineCode",{parentName:"p"},"randomInt")," is called during execution of ",(0,r.kt)("inlineCode",{parentName:"p"},"randomMultiple")," we need a\nway to spy on the ",(0,r.kt)("inlineCode",{parentName:"p"},"randomInt")," function. That could be done with either of the\nspying techniques previously mentioned. To be able to verify that the\n",(0,r.kt)("inlineCode",{parentName:"p"},"randomMultiple")," function returns the value we expect it to for what ",(0,r.kt)("inlineCode",{parentName:"p"},"randomInt"),"\nreturns, the easiest way would be to replace the ",(0,r.kt)("inlineCode",{parentName:"p"},"randomInt")," function's behavior\nwith more predictable behavior."),(0,r.kt)("p",null,"You could use the first spying technique to do that but that would require\nadding a ",(0,r.kt)("inlineCode",{parentName:"p"},"randomInt")," parameter to the ",(0,r.kt)("inlineCode",{parentName:"p"},"randomMultiple")," function."),(0,r.kt)("p",null,"You could also use the second spying technique to do that, but your assertions\nwould not be as predictable due to the ",(0,r.kt)("inlineCode",{parentName:"p"},"randomInt")," function returning random\nvalues."),(0,r.kt)("p",null,"Say we want to verify it returns correct values for both negative and positive\nrandom integers. We could easily do that with stubbing. The below example is\nsimilar to the second spying technique example but instead of passing the call\nthrough to the original ",(0,r.kt)("inlineCode",{parentName:"p"},"randomInt")," function, we are going to replace\n",(0,r.kt)("inlineCode",{parentName:"p"},"randomInt")," with a function that returns pre-defined values."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// https://deno.land/std/testing/mock_examples/random.ts\nexport function randomInt(lowerBound: number, upperBound: number): number {\n  return lowerBound + Math.floor(Math.random() * (upperBound - lowerBound));\n}\n\nexport function randomMultiple(value: number): number {\n  return value * _internals.randomInt(-10, 10);\n}\n\nexport const _internals = { randomInt };\n")),(0,r.kt)("p",null,"The mock module includes some helper functions to make creating common stubs\neasy. The ",(0,r.kt)("inlineCode",{parentName:"p"},"returnsNext")," function takes an array of values we want it to return\non consecutive calls."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'// https://deno.land/std/testing/mock_examples/random_test.ts\nimport {\n  assertSpyCall,\n  assertSpyCalls,\n  returnsNext,\n  stub,\n} from "https://deno.land/std@0.208.0/testing/mock.ts";\nimport { assertEquals } from "https://deno.land/std@0.208.0/assert/mod.ts";\nimport {\n  _internals,\n  randomMultiple,\n} from "https://deno.land/std@0.208.0/testing/mock_examples/random.ts";\n\nDeno.test("randomMultiple uses randomInt to generate random multiples between -10 and 10 times the value", () => {\n  const randomIntStub = stub(_internals, "randomInt", returnsNext([-3, 3]));\n\n  try {\n    assertEquals(randomMultiple(5), -15);\n    assertEquals(randomMultiple(5), 15);\n  } finally {\n    // unwraps the randomInt method on the _internals object\n    randomIntStub.restore();\n  }\n\n  // asserts that randomIntStub was called at least once and details about the first call.\n  assertSpyCall(randomIntStub, 0, {\n    args: [-10, 10],\n    returned: -3,\n  });\n  // asserts that randomIntStub was called at least twice and details about the second call.\n  assertSpyCall(randomIntStub, 1, {\n    args: [-10, 10],\n    returned: 3,\n  });\n\n  // asserts that randomIntStub was only called twice.\n  assertSpyCalls(randomIntStub, 2);\n});\n')),(0,r.kt)("h2",{id:"faking-time"},"Faking time"),(0,r.kt)("p",null,"Say we have a function that has time based behavior that we would like to test.\nWith real time, that could cause tests to take much longer than they should. If\nyou fake time, you could simulate how your function would behave over time\nstarting from any point in time. Below is an example where we want to test that\nthe callback is called every second."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// https://deno.land/std/testing/mock_examples/interval.ts\nexport function secondInterval(cb: () => void): number {\n  return setInterval(cb, 1000);\n}\n")),(0,r.kt)("p",null,"With ",(0,r.kt)("inlineCode",{parentName:"p"},"FakeTime")," we can do that. When the ",(0,r.kt)("inlineCode",{parentName:"p"},"FakeTime")," instance is created, it\nsplits from real time. The ",(0,r.kt)("inlineCode",{parentName:"p"},"Date"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"setTimeout"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"clearTimeout"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"setInterval"),"\nand ",(0,r.kt)("inlineCode",{parentName:"p"},"clearInterval")," globals are replaced with versions that use the fake time\nuntil real time is restored. You can control how time ticks forward with the\n",(0,r.kt)("inlineCode",{parentName:"p"},"tick")," method on the ",(0,r.kt)("inlineCode",{parentName:"p"},"FakeTime")," instance."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'// https://deno.land/std/testing/mock_examples/interval_test.ts\nimport {\n  assertSpyCalls,\n  spy,\n} from "https://deno.land/std@0.208.0/testing/mock.ts";\nimport { FakeTime } from "https://deno.land/std@0.208.0/testing/time.ts";\nimport { secondInterval } from "https://deno.land/std@0.208.0/testing/mock_examples/interval.ts";\n\nDeno.test("secondInterval calls callback every second and stops after being cleared", () => {\n  const time = new FakeTime();\n\n  try {\n    const cb = spy();\n    const intervalId = secondInterval(cb);\n    assertSpyCalls(cb, 0);\n    time.tick(500);\n    assertSpyCalls(cb, 0);\n    time.tick(500);\n    assertSpyCalls(cb, 1);\n    time.tick(3500);\n    assertSpyCalls(cb, 4);\n\n    clearInterval(intervalId);\n    time.tick(1000);\n    assertSpyCalls(cb, 4);\n  } finally {\n    time.restore();\n  }\n});\n')))}d.isMDXComponent=!0}}]);