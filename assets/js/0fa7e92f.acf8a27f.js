"use strict";(self.webpackChunkdeno_docs=self.webpackChunkdeno_docs||[]).push([[8092],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=p(n),c=i,h=u["".concat(s,".").concat(c)]||u[c]||m[c]||r;return n?a.createElement(h,o(o({ref:t},d),{},{components:n})):a.createElement(h,o({ref:t},d))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:i,o[1]=l;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},43345:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var a=n(87462),i=(n(67294),n(3905));const r={},o="Import Completions and Intelligent Registries",l={unversionedId:"manual/advanced/language_server/imports",id:"manual/advanced/language_server/imports",title:"Import Completions and Intelligent Registries",description:"The language server, supports completions for URLs.",source:"@site/runtime/manual/advanced/language_server/imports.md",sourceDirName:"manual/advanced/language_server",slug:"/manual/advanced/language_server/imports",permalink:"/runtime/manual/advanced/language_server/imports",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"runtimeGuideHome",previous:{title:"Language Server Overview",permalink:"/runtime/manual/advanced/language_server/overview"},next:{title:"Testing API",permalink:"/runtime/manual/advanced/language_server/testing_api"}},s={},p=[{value:"Local import completions",id:"local-import-completions",level:2},{value:"Workspace import completions",id:"workspace-import-completions",level:2},{value:"Module registry completions",id:"module-registry-completions",level:2},{value:"Auto-discovery",id:"auto-discovery",level:3},{value:"Configuration",id:"configuration",level:3},{value:"How does it work?",id:"how-does-it-work",level:3},{value:"Does it work with all remote modules?",id:"does-it-work-with-all-remote-modules",level:3},{value:"Registry support for import completions",id:"registry-support-for-import-completions",level:2},{value:"Configuration schema",id:"configuration-schema",level:3},{value:"Registries",id:"registries",level:3},{value:"Variables",id:"variables",level:3},{value:"URL endpoints",id:"url-endpoints",level:4},{value:"Multi-part variables and folders",id:"multi-part-variables-and-folders",level:4},{value:"Documentation endpoints",id:"documentation-endpoints",level:4},{value:"Schema validation",id:"schema-validation",level:3},{value:"Known registries",id:"known-registries",level:2}],d={toc:p},u="wrapper";function m(e){let{components:t,...n}=e;return(0,i.kt)(u,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"import-completions-and-intelligent-registries"},"Import Completions and Intelligent Registries"),(0,i.kt)("p",null,"The language server, supports completions for URLs."),(0,i.kt)("h2",{id:"local-import-completions"},"Local import completions"),(0,i.kt)("p",null,"When attempting to import a relative module specifier (one that starts with ",(0,i.kt)("inlineCode",{parentName:"p"},"./"),"\nor ",(0,i.kt)("inlineCode",{parentName:"p"},"../"),"), import completions are provided for directories and files that Deno\nthinks it can run (ending with the extensions ",(0,i.kt)("inlineCode",{parentName:"p"},".ts"),", ",(0,i.kt)("inlineCode",{parentName:"p"},".js"),", ",(0,i.kt)("inlineCode",{parentName:"p"},".tsx"),", ",(0,i.kt)("inlineCode",{parentName:"p"},".jsx"),", or\n",(0,i.kt)("inlineCode",{parentName:"p"},".mjs"),")."),(0,i.kt)("h2",{id:"workspace-import-completions"},"Workspace import completions"),(0,i.kt)("p",null,"When attempting to import a remote URL that isn't configured as a registry (see\nbelow), the extension will provide remote modules that are already part of the\nworkspace."),(0,i.kt)("h2",{id:"module-registry-completions"},"Module registry completions"),(0,i.kt)("p",null,'Module registries that support it can be configured for auto completion. This\nprovides a handy way to explore a module registry from the "comfort" of your\nIDE.'),(0,i.kt)("h3",{id:"auto-discovery"},"Auto-discovery"),(0,i.kt)("p",null,"The Deno language server, by default, will attempt to determine if a server\nsupports completion suggestions. If the host/origin has not been explicitly\nconfigured, it will check the server, and if it supports completion suggestions\nyou will be prompted to choose to enable it or not."),(0,i.kt)("p",null,"You should only enable this for registries you trust, as the remote server could\nprovide suggestions for modules which are an attempt to get you to run\nun-trusted code."),(0,i.kt)("h3",{id:"configuration"},"Configuration"),(0,i.kt)("p",null,"Settings for configuring registries for auto completions:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"deno.suggest.imports.autoDiscover")," - If enabled, when the language server\ndiscovers a new origin that isn't explicitly configured, it will check to see\nif that origin supports import completions and prompt you to enable it or not.\nThis is ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," by default.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"deno.suggest.imports.hosts")," - These are the ",(0,i.kt)("em",{parentName:"p"},"origins")," that are configured to\nprovide import completions. The target host needs to support Deno import\ncompletions (detailed below). The value is an object where the key is the host\nand the value is if it is enabled or not. For example:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "deno.suggest.imports.hosts": {\n    "https://deno.land": true\n  }\n}\n')))),(0,i.kt)("h3",{id:"how-does-it-work"},"How does it work?"),(0,i.kt)("p",null,"On startup of the extension and language server, Deno will attempt to fetch\n",(0,i.kt)("inlineCode",{parentName:"p"},"/.well-known/deno-import-intellisense.json")," from any of the hosts that are\nconfigured and enabled. This file provides the data necessary to form auto\ncompletion of module specifiers in a highly configurable way (meaning you aren't\ntied into any particular module registry in order to get a rich editor\nexperience)."),(0,i.kt)("p",null,"As you build or edit your module specifier, Deno will go and fetch additional\nparts of the URL from the host based on what is configured in the JSON\nconfiguration file."),(0,i.kt)("p",null,"When you complete the module specifier, if it isn't already cached locally for\nyou, Deno will attempt to fetch the completed specifier from the registry."),(0,i.kt)("h3",{id:"does-it-work-with-all-remote-modules"},"Does it work with all remote modules?"),(0,i.kt)("p",null,"No, as the extension and Deno need to understand how to ",(0,i.kt)("em",{parentName:"p"},"find")," modules. The\nconfiguration file provides a highly flexible way to allow people to describe\nhow to build up a URL, including supporting things like semantic versioning if\nthe module registry supports it."),(0,i.kt)("h2",{id:"registry-support-for-import-completions"},"Registry support for import completions"),(0,i.kt)("p",null,"In order to support having a registry be discoverable by the Deno language\nserver, the registry needs to provide a few things:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A schema definition file. This file needs to be located at\n",(0,i.kt)("inlineCode",{parentName:"li"},"/.well-known/deno-import-intellisense.json"),". This file provides the\nconfiguration needed to allow the Deno language server ",(0,i.kt)("em",{parentName:"li"},"query")," the registry\nand construct import specifiers."),(0,i.kt)("li",{parentName:"ul"},"A series of API endpoints that provide the values to be provided to the user\nto complete an import specifier.")),(0,i.kt)("h3",{id:"configuration-schema"},"Configuration schema"),(0,i.kt)("p",null,"The JSON response to the schema definition needs to be an object with two\nrequired properties:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},'"version"')," - a number, which must be equal to ",(0,i.kt)("inlineCode",{parentName:"li"},"1")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"2"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},'"registries"')," - an array of registry objects which define how the module\nspecifiers are constructed for this registry.")),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://deno.land/x/deno/cli/schemas/registry-completions.v2.json"},"There is a JSON Schema document which defines this\nschema available as part of the CLI's source code.")),(0,i.kt)("p",null,"While the v2 supports more features than v1 did, they were introduced in a\nnon-breaking way, and the language server automatically handles v1 or v2\nversions, irrespective of what version is supplied in the ",(0,i.kt)("inlineCode",{parentName:"p"},'"version"')," key, so\ntechnically a registry could profess itself to be v1 but use all the v2\nfeatures. This is not recommended though, because while there is no specific\nbranches in code to support the v2 features currently, that doesn't mean there\nwill not be in the future in order to support a ",(0,i.kt)("em",{parentName:"p"},"v3")," or whatever."),(0,i.kt)("h3",{id:"registries"},"Registries"),(0,i.kt)("p",null,"In the configuration schema, the ",(0,i.kt)("inlineCode",{parentName:"p"},'"registries"')," property is an array of\nregistries, which are objects which contain two required properties:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},'"schema"')," - a string, which is an Express-like path matching expression,\nwhich defines how URLs are built on the registry. The syntax is directly based\non ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/pillarjs/path-to-regexp"},"path-to-regexp"),". For example,\nif the following was the specifier for a URL on the registry:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"https://example.com/a_package@v1.0.0/mod.ts\n")),(0,i.kt)("p",{parentName:"li"},"The schema value might be something like this:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "version": 1,\n  "registries": [\n    {\n      "schema": "/:package([a-z0-9_]*)@:version?/:path*"\n    }\n  ]\n}\n'))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},'"variables"')," - for the keys defined in the schema, a corresponding variable\nneeds to be defined, which informs the language server where to fetch\ncompletions for that part of the module specifier. In the example above, we\nhad 3 variables of ",(0,i.kt)("inlineCode",{parentName:"p"},"package"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"version")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"path"),", so we would expect a\nvariable definition for each."))),(0,i.kt)("h3",{id:"variables"},"Variables"),(0,i.kt)("p",null,"In the configuration schema, the ",(0,i.kt)("inlineCode",{parentName:"p"},'"variables"')," property is an array of variable\ndefinitions, which are objects with two required properties:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},'"key"')," - a string which matches the variable key name specifier in the\n",(0,i.kt)("inlineCode",{parentName:"p"},'"schema"')," property.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},'"documentation"')," - An optional URL where the language server can fetch the\ndocumentation for an individual variable entry. Variables can be substituted\nin to build the final URL. Variables with a single brace format like\n",(0,i.kt)("inlineCode",{parentName:"p"},"${variable}")," will be added as matched out of the string, and those with\ndouble format like ",(0,i.kt)("inlineCode",{parentName:"p"},"${{variable}}")," will be percent-encoded as a URI component\npart.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},'"url"')," - A URL where the language server can fetch the completions for the\nvariable. Variables can be substituted in to build the URL. Variables with a\nsingle brace format like ",(0,i.kt)("inlineCode",{parentName:"p"},"${variable}")," will be added as matched out of the\nstring, and those with double format like ",(0,i.kt)("inlineCode",{parentName:"p"},"${{variable}}")," will be\npercent-encoded as a URI component part. If the variable the value of the\n",(0,i.kt)("inlineCode",{parentName:"p"},'"key"')," is included, then the language server will support incremental\nrequests for partial modules, allowing the server to provide completions as a\nuser types part of the variable value. If the URL is not fully qualified, the\nURL of the schema file will be used as a base. In our example above, we had\nthree variables and so our variable definition might look like:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "version": 1,\n  "registries": [\n    {\n      "schema": "/:package([a-z0-9_]*)@:version?/:path*",\n      "variables": [\n        {\n          "key": "package",\n          "documentation": "https://api.example.com/docs/packages/${package}",\n          "url": "https://api.example.com/packages/${package}"\n        },\n        {\n          "key": "version",\n          "url": "https://api.example.com/packages/${package}/versions"\n        },\n        {\n          "key": "path",\n          "documentation": "https://api.example.com/docs/packages/${package}/${{version}}/paths/${path}",\n          "url": "https://api.example.com/packages/${package}/${{version}}/paths/${path}"\n        }\n      ]\n    }\n  ]\n}\n')))),(0,i.kt)("h4",{id:"url-endpoints"},"URL endpoints"),(0,i.kt)("p",null,"The response from each URL endpoint needs to be a JSON document that is an array\nof strings or a ",(0,i.kt)("em",{parentName:"p"},"completions list"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"interface CompletionList {\n  /** The list (or partial list) of completion items. */\n  items: string[];\n  /** If the list is a partial list, and further queries to the endpoint will\n   * change the items, set `isIncomplete` to `true`. */\n  isIncomplete?: boolean;\n  /** If one of the items in the list should be preselected (the default\n   * suggestion), then set the value of `preselect` to the value of the item. */\n  preselect?: string;\n}\n")),(0,i.kt)("p",null,"Extending our example from above the URL ",(0,i.kt)("inlineCode",{parentName:"p"},"https://api.example.com/packages"),"\nwould be expected to return something like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'[\n  "a_package",\n  "another_package",\n  "my_awesome_package"\n]\n')),(0,i.kt)("p",null,"Or something like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "items": [\n    "a_package",\n    "another_package",\n    "my_awesome_package"\n  ],\n  "isIncomplete": false,\n  "preselect": "a_package"\n}\n')),(0,i.kt)("p",null,"And a query to ",(0,i.kt)("inlineCode",{parentName:"p"},"https://api.example.com/packages/a_package/versions")," would\nreturn something like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'[\n  "v1.0.0",\n  "v1.0.1",\n  "v1.1.0",\n  "v2.0.0"\n]\n')),(0,i.kt)("p",null,"Or:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "items": [\n    "v1.0.0",\n    "v1.0.1",\n    "v1.1.0",\n    "v2.0.0"\n  ],\n  "preselect": "v2.0.0"\n}\n')),(0,i.kt)("p",null,"And a query to\n",(0,i.kt)("inlineCode",{parentName:"p"},"https://api.example.com/packages/a_package/versions/v1.0.0/paths")," would return\nsomething like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'[\n  "a.ts",\n  "b/c.js",\n  "d/e.ts"\n]\n')),(0,i.kt)("p",null,"Or:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "items": [\n    "a.ts",\n    "b/c.js",\n    "d/e.ts"\n  ],\n  "isIncomplete": true,\n  "preselect": "a.ts"\n}\n')),(0,i.kt)("h4",{id:"multi-part-variables-and-folders"},"Multi-part variables and folders"),(0,i.kt)("p",null,"Navigating large file listings can be a challenge for the user. With the\nregistry V2, the language server has some special handling of returned items to\nmake it easier to complete a path to file in sub-folders easier."),(0,i.kt)("p",null,"When an item is returned that ends in ",(0,i.kt)("inlineCode",{parentName:"p"},"/"),', the language server will present it\nto the client as a "folder" which will be represented in the client. So a\nregistry wishing to provide sub-navigation to a folder structure like this:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"examples/\n\u2514\u2500\u252c\u2500 first.ts\n  \u2514\u2500 second.ts\nsub-mod/\n\u2514\u2500\u252c\u2500 mod.ts\n  \u2514\u2500 tests.ts\nmod.ts\n")),(0,i.kt)("p",null,"And had a schema like ",(0,i.kt)("inlineCode",{parentName:"p"},"/:package([a-z0-9_]*)@:version?/:path*")," and an API\nendpoint for ",(0,i.kt)("inlineCode",{parentName:"p"},"path")," like\n",(0,i.kt)("inlineCode",{parentName:"p"},"https://api.example.com/packages/${package}/${{version}}/${path}")," would want to\nrespond to the path of ",(0,i.kt)("inlineCode",{parentName:"p"},"/packages/pkg/1.0.0/")," with:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "items": [\n    "examples/",\n    "sub-mod/",\n    "mod.ts"\n  ],\n  "isIncomplete": true\n}\n')),(0,i.kt)("p",null,"And to a path of ",(0,i.kt)("inlineCode",{parentName:"p"},"/packages/pkg/1.0.0/examples/")," with:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "items": [\n    "examples/first.ts",\n    "examples/second.ts"\n  ],\n  "isIncomplete": true\n}\n')),(0,i.kt)("p",null,"This would allow the user to select the folder ",(0,i.kt)("inlineCode",{parentName:"p"},"examples")," in the IDE before\ngetting the listing of what was in the folder, making it easier to navigate the\nfile structure."),(0,i.kt)("h4",{id:"documentation-endpoints"},"Documentation endpoints"),(0,i.kt)("p",null,"Documentation endpoints should return a documentation object with any\ndocumentation related to the requested entity:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'interface Documentation {\n  kind: "markdown" | "plaintext";\n  value: string;\n}\n')),(0,i.kt)("p",null,"For extending the example from above, a query to\n",(0,i.kt)("inlineCode",{parentName:"p"},"https://api.example.com/packages/a_package")," would return something like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "kind": "markdown",\n  "value": "some _markdown_ `documentation` here..."\n}\n')),(0,i.kt)("h3",{id:"schema-validation"},"Schema validation"),(0,i.kt)("p",null,"When the language server is started up (or the configuration for the extension\nis changed) the language server will attempt to fetch and validate the schema\nconfiguration for the domain hosts specifier in the configuration."),(0,i.kt)("p",null,"The validation attempts to make sure that all registries defined are valid, that\nthe variables contained in those schemas are specified in the variables, and\nthat there aren't extra variables defined that are not included in the schema.\nIf the validation fails, the registry won't be enabled and the errors will be\nlogged to the Deno Language Server output in vscode."),(0,i.kt)("p",null,"If you are a registry maintainer and need help, advice, or assistance in setting\nup your registry for auto-completions, feel free to open up an\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/denoland/deno/issues/new?labels=lsp&title=lsp%3A%20registry%20configuration"},"issue"),"\nand we will try to help."),(0,i.kt)("h2",{id:"known-registries"},"Known registries"),(0,i.kt)("p",null,"The following is a list of registries known to support the scheme. All you need\nto do is add the domain to ",(0,i.kt)("inlineCode",{parentName:"p"},"deno.suggest.imports.hosts")," and set the value to\n",(0,i.kt)("inlineCode",{parentName:"p"},"true"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"https://deno.land/")," - both the 3rd party ",(0,i.kt)("inlineCode",{parentName:"li"},"/x/")," registry and the ",(0,i.kt)("inlineCode",{parentName:"li"},"/std/"),"\nlibrary registry are available."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"https://nest.land/")," - a module registry for Deno on the blockweave."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"https://crux.land/")," - a free open-source registry for permanently hosting\nsmall scripts.")))}m.isMDXComponent=!0}}]);