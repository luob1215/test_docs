"use strict";(self.webpackChunkdeno_docs=self.webpackChunkdeno_docs||[]).push([[2597],{3905:(e,n,t)=>{t.d(n,{Zo:()=>s,kt:()=>c});var a=t(67294);function l(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){l(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,l=function(e,n){if(null==e)return{};var t,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(l[t]=e[t]);return l}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}var d=a.createContext({}),p=function(e){var n=a.useContext(d),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},s=function(e){var n=p(e.components);return a.createElement(d.Provider,{value:n},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},k=a.forwardRef((function(e,n){var t=e.components,l=e.mdxType,r=e.originalType,d=e.parentName,s=o(e,["components","mdxType","originalType","parentName"]),u=p(t),k=l,c=u["".concat(d,".").concat(k)]||u[k]||m[k]||r;return t?a.createElement(c,i(i({ref:n},s),{},{components:t})):a.createElement(c,i({ref:n},s))}));function c(e,n){var t=arguments,l=n&&n.mdxType;if("string"==typeof e||l){var r=t.length,i=new Array(r);i[0]=k;var o={};for(var d in n)hasOwnProperty.call(n,d)&&(o[d]=n[d]);o.originalType=e,o[u]="string"==typeof e?e:l,i[1]=o;for(var p=2;p<r;p++)i[p]=t[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}k.displayName="MDXCreateElement"},96964:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var a=t(87462),l=(t(67294),t(3905));const r={},i="Foreign Function Interface",o={unversionedId:"manual/runtime/ffi_api",id:"manual/runtime/ffi_api",title:"Foreign Function Interface",description:"As of Deno 1.13 and later, the FFI (foreign function interface) API allows users",source:"@site/runtime/manual/runtime/ffi_api.md",sourceDirName:"manual/runtime",slug:"/manual/runtime/ffi_api",permalink:"/runtime/manual/runtime/ffi_api",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"runtimeGuideHome",previous:{title:"import.meta API",permalink:"/runtime/manual/runtime/import_meta_api"},next:{title:"Program Lifecycle",permalink:"/runtime/manual/runtime/program_lifecycle"}},d={},p=[{value:"Usage",id:"usage",level:2},{value:"Non-blocking FFI",id:"non-blocking-ffi",level:2},{value:"Callbacks",id:"callbacks",level:2},{value:"Supported types",id:"supported-types",level:2},{value:"deno_bindgen",id:"deno_bindgen",level:2}],s={toc:p},u="wrapper";function m(e){let{components:n,...t}=e;return(0,l.kt)(u,(0,a.Z)({},s,t,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"foreign-function-interface"},"Foreign Function Interface"),(0,l.kt)("p",null,"As of Deno 1.13 and later, the FFI (foreign function interface) API allows users\nto call libraries written in native languages that support the C ABIs (C/C++,\nRust, Zig, V, etc.) using ",(0,l.kt)("inlineCode",{parentName:"p"},"Deno.dlopen"),"."),(0,l.kt)("h2",{id:"usage"},"Usage"),(0,l.kt)("p",null,"Here's an example showing how to call a Rust function from Deno:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'// add.rs\n#[no_mangle]\npub extern "C" fn add(a: isize, b: isize) -> isize {\n    a + b\n}\n')),(0,l.kt)("p",null,"Compile it to a C dynamic library (",(0,l.kt)("inlineCode",{parentName:"p"},"libadd.so")," on Linux):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sh"},"rustc --crate-type cdylib add.rs\n")),(0,l.kt)("p",null,"In C you can write it as:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"// add.c\nint add(int a, int b) {\n  return a + b;\n}\n")),(0,l.kt)("p",null,"And compile it:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sh"},"// unix\ncc -c -o add.o add.c\ncc -shared -W -o libadd.so add.o\n// Windows\ncl /LD add.c /link /EXPORT:add\n")),(0,l.kt)("p",null,"Calling the library from Deno:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},'// ffi.ts\n\n// Determine library extension based on\n// your OS.\nlet libSuffix = "";\nswitch (Deno.build.os) {\n  case "windows":\n    libSuffix = "dll";\n    break;\n  case "darwin":\n    libSuffix = "dylib";\n    break;\n  default:\n    libSuffix = "so";\n    break;\n}\n\nconst libName = `./libadd.${libSuffix}`;\n// Open library and define exported symbols\nconst dylib = Deno.dlopen(\n  libName,\n  {\n    "add": { parameters: ["isize", "isize"], result: "isize" },\n  } as const,\n);\n\n// Call the symbol `add`\nconst result = dylib.symbols.add(35, 34); // 69\n\nconsole.log(`Result from external addition of 35 and 34: ${result}`);\n')),(0,l.kt)("p",null,"Run with ",(0,l.kt)("inlineCode",{parentName:"p"},"--allow-ffi")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"--unstable")," flag:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sh"},"deno run --allow-ffi --unstable ffi.ts\n")),(0,l.kt)("h2",{id:"non-blocking-ffi"},"Non-blocking FFI"),(0,l.kt)("p",null,"There are many use cases where users might want to run CPU-bound FFI functions\nin the background without blocking other tasks on the main thread."),(0,l.kt)("p",null,"As of Deno 1.15, symbols can be marked ",(0,l.kt)("inlineCode",{parentName:"p"},"nonblocking")," in ",(0,l.kt)("inlineCode",{parentName:"p"},"Deno.dlopen"),". These\nfunction calls will run on a dedicated blocking thread and will return a\n",(0,l.kt)("inlineCode",{parentName:"p"},"Promise")," resolving to the desired ",(0,l.kt)("inlineCode",{parentName:"p"},"result"),"."),(0,l.kt)("p",null,"Example of executing expensive FFI calls with Deno:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"// sleep.c\n#ifdef _WIN32\n#include <Windows.h>\n#else\n#include <time.h>\n#endif\n\nint sleep(unsigned int ms) {\n  #ifdef _WIN32\n  Sleep(ms);\n  #else\n  struct timespec ts;\n  ts.tv_sec = ms / 1000;\n  ts.tv_nsec = (ms % 1000) * 1000000;\n  nanosleep(&ts, NULL);\n  #endif\n}\n")),(0,l.kt)("p",null,"Calling it from Deno:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},'// nonblocking_ffi.ts\nconst library = Deno.dlopen(\n  "./sleep.so",\n  {\n    sleep: {\n      parameters: ["usize"],\n      result: "void",\n      nonblocking: true,\n    },\n  } as const,\n);\n\nlibrary.symbols.sleep(500).then(() => console.log("After"));\nconsole.log("Before");\n')),(0,l.kt)("p",null,"Result:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sh"},"$ deno run --allow-ffi --unstable unblocking_ffi.ts\nBefore\nAfter\n")),(0,l.kt)("h2",{id:"callbacks"},"Callbacks"),(0,l.kt)("p",null,"Deno FFI API supports creating C callbacks from JavaScript functions for calling\nback into Deno from dynamic libraries. An example of how callbacks are created\nand used is as follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},'// callback_ffi.ts\nconst library = Deno.dlopen(\n  "./callback.so",\n  {\n    set_status_callback: {\n      parameters: ["function"],\n      result: "void",\n    },\n    start_long_operation: {\n      parameters: [],\n      result: "void",\n    },\n    check_status: {\n      parameters: [],\n      result: "void",\n    },\n  } as const,\n);\n\nconst callback = new Deno.UnsafeCallback(\n  {\n    parameters: ["u8"],\n    result: "void",\n  } as const,\n  (success: number) => {},\n);\n\n// Pass the callback pointer to dynamic library\nlibrary.symbols.set_status_callback(callback.pointer);\n// Start some long operation that does not block the thread\nlibrary.symbols.start_long_operation();\n\n// Later, trigger the library to check if the operation is done.\n// If it is, this call will trigger the callback.\nlibrary.symbols.check_status();\n')),(0,l.kt)("p",null,"If an ",(0,l.kt)("inlineCode",{parentName:"p"},"UnsafeCallback"),"'s callback function throws an error, the error will get\npropagated up to the function that triggered the callback to be called (above,\nthat would be ",(0,l.kt)("inlineCode",{parentName:"p"},"check_status()"),") and can be caught there. If a callback returning\na value throws then Deno will return 0 (null pointer for pointers) as the\nresult."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"UnsafeCallback")," is not deallocated by default as it can cause use-after-free\nbugs. To properly dispose of an ",(0,l.kt)("inlineCode",{parentName:"p"},"UnsafeCallback")," its ",(0,l.kt)("inlineCode",{parentName:"p"},"close()")," method must be\ncalled."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-typescript"},'const callback = new Deno.UnsafeCallback(\n  { parameters: [], result: "void" } as const,\n  () => {},\n);\n\n// After callback is no longer needed\ncallback.close();\n// It is no longer safe to pass the callback as a parameter.\n')),(0,l.kt)("p",null,"It is also possible for native libraries to setup interrupt handlers and to have\nthose directly trigger the callback. However, this is not recommended and may\ncause unexpected side-effects and undefined behaviour. Preferably any interrupt\nhandlers would only set a flag that can later be polled similarly to how\n",(0,l.kt)("inlineCode",{parentName:"p"},"check_status()")," is used above."),(0,l.kt)("h2",{id:"supported-types"},"Supported types"),(0,l.kt)("p",null,"Here's a list of types supported currently by the Deno FFI API."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"FFI Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Deno"),(0,l.kt)("th",{parentName:"tr",align:null},"C"),(0,l.kt)("th",{parentName:"tr",align:null},"Rust"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"i8")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"number")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"char")," / ",(0,l.kt)("inlineCode",{parentName:"td"},"signed char")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"i8"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"u8")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"number")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"unsigned char")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"u8"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"i16")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"number")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"short int")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"i16"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"u16")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"number")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"unsigned short int")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"u16"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"i32")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"number")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"int")," / ",(0,l.kt)("inlineCode",{parentName:"td"},"signed int")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"i32"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"u32")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"number")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"unsigned int")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"u32"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"i64")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"number \\| bigint")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"long long int")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"i64"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"u64")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"number \\| bigint")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"unsigned long long int")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"u64"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"usize")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"number \\| bigint")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"size_t")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"usize"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"isize")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"number \\| bigint")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"size_t")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"isize"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"f32")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"number \\| bigint")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"float")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"f32"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"f64")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"number \\| bigint")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"double")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"f64"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"void"),"[1]"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"undefined")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"void")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"()"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"pointer")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"{} \\| null")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"void *")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"*mut c_void"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"buffer"),"[2]"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"TypedArray \\| null")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"uint8_t *")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"*mut u8"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"function"),"[3]"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"{} \\| null")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"void (*fun)()")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},'Option<extern "C" fn()>'))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"{ struct: [...] }"),"[4]"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"TypedArray")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"struct MyStruct")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"MyStruct"))))),(0,l.kt)("p",null,"As of Deno 1.25, the ",(0,l.kt)("inlineCode",{parentName:"p"},"pointer")," type has been split into a ",(0,l.kt)("inlineCode",{parentName:"p"},"pointer")," and a\n",(0,l.kt)("inlineCode",{parentName:"p"},"buffer")," type to ensure users take advantage of optimizations for Typed Arrays,\nand as of Deno 1.31 the JavaScript representation of ",(0,l.kt)("inlineCode",{parentName:"p"},"pointer")," has become an\nopaque pointer object or ",(0,l.kt)("inlineCode",{parentName:"p"},"null")," for null pointers."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"[1]"," ",(0,l.kt)("inlineCode",{parentName:"li"},"void")," type can only be used as a result type."),(0,l.kt)("li",{parentName:"ul"},"[2]"," ",(0,l.kt)("inlineCode",{parentName:"li"},"buffer")," type accepts TypedArrays as parameter, but it always returns a\npointer object or ",(0,l.kt)("inlineCode",{parentName:"li"},"null")," when used as result type like the ",(0,l.kt)("inlineCode",{parentName:"li"},"pointer")," type."),(0,l.kt)("li",{parentName:"ul"},"[3]"," ",(0,l.kt)("inlineCode",{parentName:"li"},"function")," type works exactly the same as the ",(0,l.kt)("inlineCode",{parentName:"li"},"pointer")," type as a\nparameter and result type."),(0,l.kt)("li",{parentName:"ul"},"[4]"," ",(0,l.kt)("inlineCode",{parentName:"li"},"struct")," type is for passing and returning C structs by value (copy). The\n",(0,l.kt)("inlineCode",{parentName:"li"},"struct")," array must enumerate each of the struct's fields' type in order. The\nstructs are padded automatically: Packed structs can be defined by using an\nappropriate amount of ",(0,l.kt)("inlineCode",{parentName:"li"},"u8")," fields to avoid padding. Only TypedArrays are\nsupported as structs, and structs are always returned as ",(0,l.kt)("inlineCode",{parentName:"li"},"Uint8Array"),"s.")),(0,l.kt)("h2",{id:"deno_bindgen"},"deno_bindgen"),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"https://github.com/denoland/deno_bindgen"},(0,l.kt)("inlineCode",{parentName:"a"},"deno_bindgen"))," is the official tool\nto simplify glue code generation of Deno FFI libraries written in Rust."),(0,l.kt)("p",null,"It is similar to ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/rustwasm/wasm-bindgen"},(0,l.kt)("inlineCode",{parentName:"a"},"wasm-bindgen"))," in\nthe Rust WASM ecosystem."),(0,l.kt)("p",null,"Here's an example showing its usage:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"// mul.rs\nuse deno_bindgen::deno_bindgen;\n\n#[deno_bindgen]\nstruct Input {\n  a: i32,\n  b: i32,\n}\n\n#[deno_bindgen]\nfn mul(input: Input) -> i32 {\n  input.a * input.b\n}\n")),(0,l.kt)("p",null,"Run ",(0,l.kt)("inlineCode",{parentName:"p"},"deno_bindgen")," to generate bindings. You can now directly import them into\nDeno:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts,",metastring:"ignore",ignore:!0},'// mul.ts\nimport { mul } from "./bindings/bindings.ts";\nmul({ a: 10, b: 2 }); // 20\n')),(0,l.kt)("p",null,"Any issues related to ",(0,l.kt)("inlineCode",{parentName:"p"},"deno_bindgen")," should be reported at\n",(0,l.kt)("a",{parentName:"p",href:"https://github.com/denoland/deno_bindgen/issues"},"https://github.com/denoland/deno_bindgen/issues")))}m.isMDXComponent=!0}}]);